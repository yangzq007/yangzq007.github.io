<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那片树海</title>
  <subtitle>用心做一件工艺品</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-08T02:40:59.991Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>树海</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>主题替换为NexT</title>
    <link href="http://yoursite.com/2018/04/04/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2%E4%B8%BANexT/"/>
    <id>http://yoursite.com/2018/04/04/主题替换为NexT/</id>
    <published>2018-04-04T08:28:10.000Z</published>
    <updated>2018-04-08T02:40:59.991Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直觉得博客的主题在显示比较多的文字和代码的时候略显凌乱，而且不太方便阅读，所以就把博客主题替换成了NexT。NexT在文字排版上比较清晰，而且界面元素也不多，可以使自己把更多的关注点放在内容上。</p>
<p>NexT主题地址：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a></p>
<h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>1.NexT有4个scheme，每个scheme对应一个不同的布局，可以在<code>_config.yml</code>当中设置</p>
<pre><code># ---------------------------------------------------------------
# Scheme Settings
# ---------------------------------------------------------------

# Schemes
scheme: Muse
# scheme: Mist
#scheme: Pisces
</code></pre><p>2.大于5.0.1小于6.0.0版本的NexT在<code>sudo hexo generate</code>时速度会特别慢，不知道是不是个例，在使用的时候注意一下</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直觉得博客的主题在显示比较多的文字和代码的时候略显凌乱，而且不太方便阅读，所以就把博客主题替换成了NexT。NexT在文字排版上比较清晰，而且界面元素也不多，可以使自己把更多的关注点放在内容上。&lt;/p&gt;
&lt;p&gt;NexT主题地址：&lt;a href=&quot;https://git
    
    </summary>
    
    
      <category term="博客历程" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从ReactNative到React</title>
    <link href="http://yoursite.com/2018/03/29/%E4%BB%8EReactNative%E5%88%B0React/"/>
    <id>http://yoursite.com/2018/03/29/从ReactNative到React/</id>
    <published>2018-03-29T01:44:31.000Z</published>
    <updated>2018-04-04T02:41:06.021Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写自己的一个前端小Demo，因为之前在工作中使用了ReactNative，就选择了React作为技术选型，也就走上了这么一条自上而下的路。本文主要内容为ReactNative和Reactjs的一些不同以及从ReactNative到Reactjs的一些开发中的经验，因此适合从原生转向前端或者对前端有些兴趣的同学，希望能帮大家少踩一些坑，少费一些力。</p>
<h3 id="安装脚手架和搭建基础工程"><a href="#安装脚手架和搭建基础工程" class="headerlink" title="安装脚手架和搭建基础工程"></a>安装脚手架和搭建基础工程</h3><pre><code>//-g是将create-react-app安装到全局，该电脑的任何用户都可以使用
npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
</code></pre><p>这样我们就有一个基础的工程和基础的页面了，下面我们就开始讨论详细的问题了</p>
<h3 id="1-自定义字体问题"><a href="#1-自定义字体问题" class="headerlink" title="1.自定义字体问题"></a>1.自定义字体问题</h3><p>自定义字体首先我们需要下载相应的字体并放到工程当中，然后在工程的App.css文件当中添加<code>@font-face</code>，实例如下：</p>
<pre><code>@font-face
{
font-family: EBGaramond;                //EBGaramond为自定义名称
src: url(&apos;EBGaramond08-Italic.ttf&apos;)
}
</code></pre><p>然后我们就可以在App.js当中和其他页面文件当中使用<code>fontFamily: &#39;EBGaramond&#39;</code>了</p>
<p>我们也可以自己新建一个css文件，但是要记得在App.js和页面文件当中导入</p>
<h3 id="2-文件重复导入问题"><a href="#2-文件重复导入问题" class="headerlink" title="2.文件重复导入问题"></a>2.文件重复导入问题</h3><pre><code>import &apos;./App.css&apos;;
import &apos;./Font.css&apos;;
</code></pre><p>这种导入整个文件的方式导入后是全局的，顶级文件导入后其他地方就不再需要导入了，与导入类不同，导入类需要在每个使用的页面导入</p>
<h3 id="3-布局方式问题-1"><a href="#3-布局方式问题-1" class="headerlink" title="3.布局方式问题-1"></a>3.布局方式问题-1</h3><p>ReactNative当中默认使用的是flex布局，flex-direction为column，而在Reactjs当中布局方式为一个从上往下的流式布局（该名词有待商榷，因为暂时不了解一些前端术语，故先这么称呼），这就需要我们修改它的布局方式。我的第一反应是在css添加这样一个样式</p>
<pre><code>.content {
  display: flex;
  flex-direction: column
}
</code></pre><p>但是这种方式需要每个页面都需要写一个content的选择器，后来我就改成了这种方式</p>
<pre><code>body *:not(style) {
  display: flex;
  flex-direction: column    //Reactjs当中flex-direction默认为row，需要修改
}
</code></pre><p>至于为什么是<code>body *:not(style)</code>，那是因为*会把<code>header</code>，<code>body</code>，<code>footer</code>当中的所有内容都会当做html元素，所以我们只需要让body当中的所有内容使用flex布局即可，至于为什么有<code>not(style)</code>，那是因为它还会把body当中的style作为html元素，所以要除开。</p>
<h3 id="4-布局方式问题-2"><a href="#4-布局方式问题-2" class="headerlink" title="4.布局方式问题-2"></a>4.布局方式问题-2</h3><p>在使用了flex布局之后，你会发现当一行元素填充满的时候，这些元素并不会换行，那是因为在Reactjs当中flexWrap默认为nowrap，需要设置为wrap</p>
<pre><code>body *:not(style) {
      display: flex;
      flex-direction: column;    //Reactjs当中flex-direction默认为row，需要修改
      flexWrap: wrap
}
</code></pre><p>在js样式文件中为</p>
<pre><code>const styles = {
    content: {
        flexWrap: &apos;wrap&apos;
    }
};
</code></pre><h3 id="其他后续更新中"><a href="#其他后续更新中" class="headerlink" title="其他后续更新中"></a>其他后续更新中</h3><p>……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写自己的一个前端小Demo，因为之前在工作中使用了ReactNative，就选择了React作为技术选型，也就走上了这么一条自上而下的路。本文主要内容为ReactNative和Reactjs的一些不同以及从ReactNative到Reactjs的一些开发中的经验，因此
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2017年个人总结</title>
    <link href="http://yoursite.com/2018/01/09/2017%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/09/2017年个人总结/</id>
    <published>2018-01-09T10:06:59.000Z</published>
    <updated>2018-04-04T02:43:39.086Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o84wamnts.bkt.clouddn.com/20180109-1.jpg" alt="20180109-1"></p>
<a id="more"></a>
<p>最近手头事情终于不是那么多了，也可以静下来做个2017年的总结了，给自己打个tag，也希望自己新的一年能够继续努力。</p>
<h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>工作内容大致有以下几点：</p>
<ul>
<li>日常Native </li>
<li>ReactNative及前端相关</li>
<li>工程结构调整和优化</li>
<li>脚本工具</li>
</ul>
<p>一些计划：</p>
<ul>
<li>逆向</li>
</ul>
<p>今年工作没有太大的变动，整体比较稳定，在这过去的一年中，感觉自己收获还是蛮大的。</p>
<h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>好的方面：</p>
<p>作息比以前规律了<br>自己开始做饭了</p>
<p>坏的方面：</p>
<p>打羽毛球的习惯冬天中断了</p>
<p>希望天气稍微转暖之后可以恢复打球活动，另外再加强一下其他锻炼，毕竟身体是革命的本钱。同时也希望自己多去其他地方走走，收获一些不同的体验和感受。</p>
<h3 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h3><ul>
<li>《人类简史》</li>
</ul>
<p>今年的人文阅读似乎有点少，希望18年可以稍微改进下，但是也不打算强迫自己，这种东西随性就好，毕竟记忆和感受才是重点。</p>
<h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>转眼博客已经走过了两年，希望自己能再接再厉，把这个好习惯坚持下去，也希望将来有一天它能见证自己这一路走来的足迹。</p>
<h3 id="其他感慨"><a href="#其他感慨" class="headerlink" title="其他感慨"></a>其他感慨</h3><p>今年过的好快……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o84wamnts.bkt.clouddn.com/20180109-1.jpg&quot; alt=&quot;20180109-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>MobX绑定过程和其中的一些坑的总结</title>
    <link href="http://yoursite.com/2017/10/19/MobX%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B%E5%92%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/19/MobX绑定过程和其中的一些坑的总结/</id>
    <published>2017-10-19T07:03:15.000Z</published>
    <updated>2018-04-04T06:28:22.307Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o84wamnts.bkt.clouddn.com/20171019-1.png" alt="20171019-1"></p>
<a id="more"></a>
<p>开发过程中使用Mobx极大的方便了我们，但是在使用过程中还是会或多或少地遇到一些问题导致绑定失败，下面我们来一起探讨下Mobx的绑定过程，以方便我们来更好的使用它。</p>
<blockquote>
<p>MobX 会对在追踪函数执行过程中读取现存的可观察属性做出反应。</p>
</blockquote>
<p>MobX的官方文档将MobX的绑定及相应过程总结为这么一句话，并标出了“读取”、“追踪函数”和“过程”三个关键字。</p>
<h3 id="Mobx会收集哪些地方的绑定"><a href="#Mobx会收集哪些地方的绑定" class="headerlink" title="Mobx会收集哪些地方的绑定"></a>Mobx会收集哪些地方的绑定</h3><blockquote>
<p>“追踪函数” 是 <code>computed</code> 表达式、<code>observer</code> 组件的 <code>render()</code> 方法和 <code>when</code>、<code>reaction</code> 和 <code>autorun</code> 的第一个入参函数。</p>
</blockquote>
<p>文档说明的也比较清楚，会对文件当中的<code>@computed</code>修饰的方法、<code>render()</code>方法、<code>when</code>方法的第一个入参函数、<code>reaction</code>方法的第一个入参函数、<code>autorun</code>方法的第一个入参函数这些地方收集，MobX会在页面加载执行前扫描所有的文件，收集这些地方的绑定。</p>
<p>以下调用和赋值<code>this.store.listA</code>的地方，MobX都会去收集绑定，其它的地方则不会去收集。</p>
<pre><code>//数据绑定文件
import { computed, observable } from &apos;mobx&apos;;

class IndexStore {
    @observable listA = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];
    @observable listB = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];

    @computed get dataA() {
        return this.listA;
    }
}

//Index视图文件
import { observer } from &apos;mobx-react/native&apos;;
import IndexStore from &apos;indexStore&apos;;

@observer
class Index extends Component {
    constructor() {
        super();
        this.store = new IndexStore();
        when(
            () =&gt; this.store.listA.length == 0,
            () =&gt; console.log(&quot;listA none&quot;)
        );
    }

    const autorun1 = autorun(() =&gt; {
        console.log(this.store.listA);
    })

    const reaction2 = reaction(
        () =&gt; this.store.listA,
        listA =&gt; console.log(listA.join(&quot;, &quot;))
    )

    render() {
        return (
            &lt;MainItem dataSource={this.store.listA}
            renderHeader={
                () =&gt; &lt;Item data={this.store.listB}&gt;&lt;/Item&gt;
            } /&gt;
        )
    }
}
</code></pre><h3 id="MobX会收集哪些绑定"><a href="#MobX会收集哪些绑定" class="headerlink" title="MobX会收集哪些绑定"></a>MobX会收集哪些绑定</h3><blockquote>
<p>“过程(during)” 意味着只追踪那些在函数执行时被读取的 <code>observable</code> 。这些值是否由追踪函数直接或间接使用并不重要。</p>
</blockquote>
<p>这句话解释了MobX收集哪些绑定，是那些在函数执行时被读取的<code>observable</code>，例如上面实例代码<code>&lt;MainItem dataSource={this.store.listA}/&gt;</code>中的<code>this.store.listA</code>，它在<code>render()</code>函数执行时被调用，用于作为<code>MainItem</code>的数据源，所以这个绑定就被收集到了，<code>render()</code>函数和<code>listA</code>之间就建立了联系，当<code>listA</code>发生变化时，<code>render()</code>函数就会被调用，界面也就从新渲染刷新了。同理，上面的一些log也会调用，会在控制台输出相应信息。</p>
<p>需要注意的是上面实例代码中的<code>renderHeader={() =&gt; &lt;Item data={this.store.listB}&gt;&lt;/Item&gt;}</code>当中的<code>this.store.listB</code>并不会被收集到，为什么呢？因为<code>renderHeader</code>作为一个属性传入<code>MainItem</code>，<code>renderHeader</code>当中的<code>this.store.listB</code>并没有在<code>Index</code>的<code>render()</code>去使用，而是在<code>Item</code>当中使用了它，所以<code>Index</code>的<code>render()</code>并没有与<code>listB</code>之间建立连接，当<code>listB</code>发生变化就不会调用<code>Index</code>的<code>render()</code>，界面也就不会重新渲染刷新。</p>
<p>我们想在修改<code>listB</code>时让界面刷新作出相应，我们该怎么办呢？我们需要在<code>Item</code>当中添加<code>@observer</code>去捕获这个绑定，因为<code>listB</code>在<code>Item</code>的<code>render()</code>当中进行了调用，所以正确的写法如下：</p>
<pre><code>//Index视图文件
render() {
    return (
        &lt;MainItem dataSource={this.store.listA}
             renderHeader={
                   () =&gt; &lt;Item data={this.store}&gt;&lt;/Item&gt;
         } /&gt;
    )
}

//Item视图文件
import { observer } from &apos;mobx-react/native&apos;;

@observer
class Item extends Component {
    constructor() {
        super();
    }

    render() {
        return (
            &lt;Text&gt;{this.props.data.listB[0]}&lt;/Text&gt;
        )
    }
}
</code></pre><p>Tips：当我们修改<code>listB</code>时，<code>Item</code>就会重新调用其<code>render()</code>函数重新渲染，我们重新渲染<code>Item</code>比重新渲染整个<code>Index</code>所消耗的资源会更少，虽然MobX已经有机制帮我们减少不必要的渲染，但是这样还是会消耗更少的资源，所以官方推荐我们绑定粒度越细越好。</p>
<p>细心的同学可能会注意到为什么<code>Item</code>的<code>data</code>当中是<code>this.store</code>而不是我们认为的<code>this.store.listB</code>，是写错了吗，并不是，这恰恰是正确的写法，下面我们就来讨论下这个问题。</p>
<h3 id="MobX绑定了什么"><a href="#MobX绑定了什么" class="headerlink" title="MobX绑定了什么"></a>MobX绑定了什么</h3><blockquote>
<p>“读取” 是对象属性的间接引用，可以用过 <code>.</code> (例如 <code>user.name</code>) 或者 <code>[]</code> (例如 <code>user[&#39;name&#39;]</code>) 的形式完成。</p>
</blockquote>
<p>这句话解释了MobX绑定了什么，它绑定的是可观察对象的引用，例如上面提到的<code>listA</code>，MobX并不是将<code>listA</code>的内容<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code>与<code>render()</code>函数绑定，而是将<code>listA</code>变量对<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code>的引用与<code>render()</code>函数绑定绑定，所以只有当<code>listA</code>对值的引用发生变化时，<code>render()</code>函数才会调用。（也可以理解为c/c++当中的指针的概念，<code>render()</code>函数是与<code>listA</code>变量的指针值绑定）</p>
<p>所以针对上面的<code>listA</code>，你只修改数组的内容，render()函数是不会调用的，界面也是不会刷新的。下面这种写法，界面并不会刷新：</p>
<pre><code>//数据绑定文件
modifyListA1() {
    this.listA[0] = &quot;4&quot;;
}

//此处只是数组[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]的内容发生了变化，listA的引用却没有发生变化
</code></pre><p>正确的写法</p>
<pre><code>//数据绑定文件
modifyListA2() {
    this.listA = [&quot;4&quot;,&quot;2&quot;,&quot;3&quot;];
}

//此处listA被赋值了一个新数组[&quot;4&quot;,&quot;2&quot;,&quot;3&quot;]，listA的引用发生了变化
</code></pre><p>我们再回到<code>listB</code>的问题上，如果我们是<code>&lt;Item data={this.store.listB}&gt;&lt;/Item&gt;</code>这种写法，我们相当于把<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>这个值传递给了<code>Item</code>当中的<code>data</code>，通过<code>data</code>对数组的操作，并未出现<code>listB</code>的引用，也就无法建立绑定。而我们将整个<code>store</code>传递过去，<code>data</code>就被赋值了<code>store</code>的内容，当<code>data</code>引用<code>listB</code>时，也就出现了<code>listB</code>的引用，这样绑定才建立了起来。</p>
<p>所以针对子组件，需要将被观察属性的父级传递过去，这样才能在子组件中出现被观察属性的引用，才能建立绑定。</p>
<h3 id="MobX绑定过程"><a href="#MobX绑定过程" class="headerlink" title="MobX绑定过程"></a>MobX绑定过程</h3><p>了解了以上三个概念，MobX的绑定过程就比较清晰了。MobX在代码编译时/代码执行之前扫描代码中的<code>computed</code> 表达式、<code>observer</code> 组件的 <code>render()</code> 方法等地方，将这些方法中出现的直接调用的观察属性的引用和这些方法绑定起来，这就是MobX的绑定过程。绑定完成之后，当这些引用发生变化时，相应的绑定方法就调用，界面就会刷新重新渲染或者相应的逻辑就会执行。</p>
<h3 id="observable和-observable"><a href="#observable和-observable" class="headerlink" title="observable和@observable"></a>observable和@observable</h3><p>上面我们<code>modifyListA1</code>提到的修改并不会触发绑定的界面刷新操作，需要我们使用<code>modifyListA2</code>当中的修改方式，给<code>listA</code>提供一个新数组，改变它的引用值。那有没有方法可以让<code>listA</code>只修改一个值（如<code>modifyListA1</code>当中的操作）就触发界面的刷新呢，答案是肯定的，我们只需要将<code>listA</code>初始的赋值方式改成如下方式即可：</p>
<pre><code>//数据绑定文件
import { computed, observable } from &apos;mobx&apos;;

class IndexStore {
    listA = observable([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]);
    @observable listB = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];

    @computed get dataA() {
        return this.listA;
    }
}
</code></pre><p>为什么这种方式就可以呢？因为<code>observable</code>默认情况下会递归应用，相比较<code>@observable</code>细粒度的观察，只监测<code>listA</code>的引用，<code>observable</code>则会递归这些观察，将<code>listA[0]</code>、<code>listA[1]</code>、<code>listA[2]</code>的引用都作为监测对象，这样<code>listA[0]</code>、<code>listA[1]</code>、<code>listA[2]</code>的引用就和<code>render()</code>函数建立起了绑定，当<code>listA[0]</code>被赋值，引用发生变化时，<code>render()</code>也就被调用了，界面也就刷新了。</p>
<p>如果需要一个数据源的内部数据发生变化引起相应操作，我们可以使用<code>observable</code>，然而<code>observable</code>也有它的弊端，它会建立起来比较多的冗余绑定，也会使后续的维护变得复杂，总体上我们推荐使用<code>@observable</code>这样细粒度的控制，它会使我们的项目更加清晰便于维护，同时也会大大的降低那些莫名其妙的bug的概率。</p>
<h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><p>详情参考官方文档</p>
<p><a href="http://cn.mobx.js.org/best/react.html" target="_blank" rel="external">MobX 会对什么作出反应?</a></p>
<p><a href="http://cn.mobx.js.org/best/pitfalls.html" target="_blank" rel="external">常见陷阱与最佳实践</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o84wamnts.bkt.clouddn.com/20171019-1.png&quot; alt=&quot;20171019-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Xcode9的一些问题</title>
    <link href="http://yoursite.com/2017/10/10/Xcode9%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/10/Xcode9的一些问题/</id>
    <published>2017-10-10T09:55:37.000Z</published>
    <updated>2018-04-04T06:29:27.008Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode9的正式版也使用了一段时间了，bug还是有点多的，总感觉好像是赶工出来的版本，刚开始用的时候还是有点痛苦的，下面就把这些点列出来，大家可以参考一下。</p>
<h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h3><p>1.APP图标不见了</p>
<p>用Xcode9跑起来工程之后发现应用图标不见了，这个是因为CocoaPods的资源脚本有点问题，在Xcode9上资源位置异常，工程引用不到，解决方案是在Podfile添加如下hook代码</p>
<pre><code>post_install do |installer|
    copy_pods_resources_path = &quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&quot;
    string_to_replace = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;&apos;
    assets_compile_with_app_icon_arguments = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot; --app-icon &quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&quot; --output-partial-info-plist &quot;${BUILD_DIR}/assetcatalog_generated_info.plist&quot;&apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &quot;w&quot;) {|file| file.puts new_contents }
end

//如果有多个TARGETS，遍历执行即可
post_install do |installer|
  installer.aggregate_targets.each do |target|
    copy_pods_resources_path = &quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&quot;
    string_to_replace = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;&apos;
    assets_compile_with_app_icon_arguments = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot; --app-icon &quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&quot; --output-partial-info-plist &quot;${BUILD_DIR}/assetcatalog_generated_info.plist&quot;&apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &quot;w&quot;) {|file| file.puts new_contents }
  end
end
</code></pre><a id="more"></a>
<p>2.替换或者新添加文件时工程找不到文件</p>
<p>具体表现为报错<code>symbol(s) not found for architecture x86_64</code>，这个是Xcode9没有在我们添加文件时将相关文件添加到编译配置当中，只需要在工程-&gt;TARGETS-&gt;Build Phases-&gt;Compile Sources当中手动添加进去即可</p>
<p>3.打包导出（Export）失败</p>
<p>表现为点击Xcode的导出（Export）时提示<code>The data couldn’t be read because it isn’t in the correct format.</code>或者使用Jenkins等用脚本打包提示如下错误：</p>
<pre><code>2017-10-20 11:42:44.254 xcodebuild[6983:599869] [MT] IDEDistribution: Step failed: &lt;IDEDistributionSigningAssetsStep: 0x7fa541fd34a0&gt;: Error Domain=IDEDistributionSigningAssetStepErrorDomain Code=0 &quot;Locating signing assets failed.&quot; UserInfo={NSLocalizedDescription=Locating signing assets failed.,
IDEDistributionSigningAssetStepUnderlyingErrors=(
    &quot;Error Domain=IDEProvisioningErrorDomain Code=9 \&quot;\&quot;PrePublish.app\&quot; requires a provisioning profile with the Push Notifications feature.\&quot; UserInfo={NSLocalizedDescription=\&quot;PrePublish.app\&quot; requires a provisioning profile with the Push Notifications feature., NSLocalizedRecoverySuggestion=Add a profile to the \&quot;provisioningProfiles\&quot; dictionary in your Export Options property list.}&quot;
)}
</code></pre><p>原因是Xcode9帮你添加了一个<code>Code Signing Style</code>的配置字段，该字段需要和<code>Automatically manage signing</code>对应，使用<code>Automatically manage signing</code>时该字段的值需要为<code>Automatic</code>，不使用<code>Automatically manage signing</code>时该字段的值需要为<code>Manual</code>，上述错误就是因为配置不对应导致的，修改对应即可。</p>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>1.主题</p>
<p>部分经典主题在Theme列表看不到，只需要点击theme列表下面的“+”号即可添加，具体位置为Xcode-&gt;Preferences-&gt;Fonts &amp; Colors-&gt;左侧Theme-&gt;“+”</p>
<p>2.移除模拟器边框</p>
<p>取消勾选Simulator-&gt;Window-&gt;Show Device Bezels</p>
<p>3.单击跳转方法定义</p>
<p>Xcode9给“cmd+单击”添加了一个菜单选项，可以提供更多操作，如下：<br><img src="http://o84wamnts.bkt.clouddn.com/20171011-1.png" alt="20171011-1"></p>
<p>如果我们想直接跳转到方法定义，我们可以直接“cmd+鼠标右键”，触摸板是“cmd+双指轻击”</p>
<p>如果还是习惯原来的“cmd+单击”的方式，也可以在Xcode-&gt;Preferences-&gt;Navigation-&gt;Command-click on Code中将选项修改为Jumps To Definition，这样“cmd+单击”就是直接跳转到代码定义了。<br><img src="http://o84wamnts.bkt.clouddn.com/20171011-3.png" alt="20171011-3"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xcode9的正式版也使用了一段时间了，bug还是有点多的，总感觉好像是赶工出来的版本，刚开始用的时候还是有点痛苦的，下面就把这些点列出来，大家可以参考一下。&lt;/p&gt;
&lt;h3 id=&quot;BUG&quot;&gt;&lt;a href=&quot;#BUG&quot; class=&quot;headerlink&quot; title=&quot;BUG&quot;&gt;&lt;/a&gt;BUG&lt;/h3&gt;&lt;p&gt;1.APP图标不见了&lt;/p&gt;
&lt;p&gt;用Xcode9跑起来工程之后发现应用图标不见了，这个是因为CocoaPods的资源脚本有点问题，在Xcode9上资源位置异常，工程引用不到，解决方案是在Podfile添加如下hook代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;post_install do |installer|
    copy_pods_resources_path = &amp;quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&amp;quot;
    string_to_replace = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot;&amp;apos;
    assets_compile_with_app_icon_arguments = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot; --app-icon &amp;quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&amp;quot; --output-partial-info-plist &amp;quot;${BUILD_DIR}/assetcatalog_generated_info.plist&amp;quot;&amp;apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &amp;quot;w&amp;quot;) {|file| file.puts new_contents }
end

//如果有多个TARGETS，遍历执行即可
post_install do |installer|
  installer.aggregate_targets.each do |target|
    copy_pods_resources_path = &amp;quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&amp;quot;
    string_to_replace = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot;&amp;apos;
    assets_compile_with_app_icon_arguments = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot; --app-icon &amp;quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&amp;quot; --output-partial-info-plist &amp;quot;${BUILD_DIR}/assetcatalog_generated_info.plist&amp;quot;&amp;apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &amp;quot;w&amp;quot;) {|file| file.puts new_contents }
  end
end
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://yoursite.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>一行命令搞定工程图片浏览查找</title>
    <link href="http://yoursite.com/2017/09/12/%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%90%9E%E5%AE%9A%E5%B7%A5%E7%A8%8B%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2017/09/12/一行命令搞定工程图片浏览查找/</id>
    <published>2017-09-12T06:26:59.000Z</published>
    <updated>2018-04-04T06:49:37.321Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开发过程中随着项目的逐渐增大，项目当中的图片资源会越来越多，而且有些时候因为命名不规范和人员的变动等原因会造成项目当中重复的图片资源越来越多，而且Xcode查看图片的方式也不集中，查找起来也不方便，这种情况下我们往往会更倾向于添加一个新的图片资源，从而更加剧了图片资源重复的问题。</p>
<p>为了解决这个问题，我们打算来写一个脚本，把工程当中图片数据扫描一遍，然后用html集中显示出来，这样就方便我们来查找了。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们基本上需要解决以下3个问题</p>
<ol>
<li>工程资源文件扫描脚本的编写</li>
<li>html展示页面的编写</li>
<li>html页面和扫描脚本的数据交互</li>
</ol>
<p>1和2两点查阅相关资料就可以比较容易解决，主要是第3点，一般情况下浏览器是不提供操作文件的接口的，网上说的<code>ActiveXObject</code>也只是IE浏览器提供。这个地方我们采用了一个比较特殊的方式，就是将脚本扫描得到的数据直接利用脚本的文件操作写成一个js文件，虽然浏览器不能操作文件，但是可以直接读取js文件，这样就比较好的解决了脚本和html交互的问题。<a id="more"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>脚本采用python实现，是一个递归查找并记录的过程，代码整体逻辑并不复杂，表现层的html也都是比较简单的原生html代码和js代码，这里就不做详细介绍了，我们简单的看下检查依赖和数据交互的逻辑。</p>
<p>下面这段代码就是检查依赖的方法，以前都是在文档当中提示使用者手动安装，现在我们可以用这样一个方法检索用户的特定库的安装列表，如果没有安装相应库，则执行相应命令帮其安装。</p>
<pre><code>def checkDepend():
    print &quot;检查依赖库...&quot;
    isHavePillow = False
    r = os.popen(&quot;pip freeze&quot;)
    x = r.readlines()
    for line in x:
        if line.startswith(&quot;Pillow=&quot;):
            isHavePillow = True
    if isHavePillow:
        print &quot;依赖库存在&quot;
    else:
        print &quot;依赖库不存在，安装依赖库...&quot;
        os.system(&quot;sudo pip install Pillow&quot;)
        print &quot;依赖库安装完成&quot;
</code></pre><p>下面这个方法就是将检索到数据生成js的方法，我们可以看到它是直接将数组当中的内容转化为json并拼接成一个赋值给imageData变量的字符串，利用python的文件操作，将此字符串写入一个名为imageData.js的文件当中，这样就可以被html引用并操作imageData变量了。</p>
<pre><code>def generateJSFile(mArrImageData):
    if os.path.exists(&quot;./imageData.js&quot;):
        os.remove(&quot;./imageData.js&quot;)
    f = open(&quot;./imageData.js&quot;, &apos;w&apos;)
    strJson = json.dumps({&quot;data&quot;:mArrImageData})
    strDes = &quot;var imageData = &quot; + strJson
    # print strJson
    f.write(strDes)
    f.close()
</code></pre><p>源代码请戳这里<a href="https://github.com/yangzq007/SHScript/tree/master/FindImage" target="_blank" rel="external">FindImage</a>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将源代码clone或者下载到本地，并根据README当中提示修改<code>path</code>为自己的工程目录，然后执行下面命令，脚本便会帮你检索并打开相应的浏览页面，轻松一行命令搞定。</p>
<pre><code>python findImage.py
</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>html5提供了读取文件的API——FileReader，利用它来实现数据交互也是一个不错的选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目开发过程中随着项目的逐渐增大，项目当中的图片资源会越来越多，而且有些时候因为命名不规范和人员的变动等原因会造成项目当中重复的图片资源越来越多，而且Xcode查看图片的方式也不集中，查找起来也不方便，这种情况下我们往往会更倾向于添加一个新的图片资源，从而更加剧了图片资源重复的问题。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们打算来写一个脚本，把工程当中图片数据扫描一遍，然后用html集中显示出来，这样就方便我们来查找了。&lt;/p&gt;
&lt;h3 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h3&gt;&lt;p&gt;我们基本上需要解决以下3个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工程资源文件扫描脚本的编写&lt;/li&gt;
&lt;li&gt;html展示页面的编写&lt;/li&gt;
&lt;li&gt;html页面和扫描脚本的数据交互&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1和2两点查阅相关资料就可以比较容易解决，主要是第3点，一般情况下浏览器是不提供操作文件的接口的，网上说的&lt;code&gt;ActiveXObject&lt;/code&gt;也只是IE浏览器提供。这个地方我们采用了一个比较特殊的方式，就是将脚本扫描得到的数据直接利用脚本的文件操作写成一个js文件，虽然浏览器不能操作文件，但是可以直接读取js文件，这样就比较好的解决了脚本和html交互的问题。
    
    </summary>
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>一个优雅的水波动画</title>
    <link href="http://yoursite.com/2017/08/11/%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84%E6%B0%B4%E6%B3%A2%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/08/11/一个优雅的水波动画/</id>
    <published>2017-08-11T02:51:04.000Z</published>
    <updated>2018-04-04T06:50:31.863Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理文件的时候发现以前写的一个动画，感觉还不错，就和大家分享一下。</p>
<p>如何实现一个如下图的动画呢？</p>
<p><img src="http://o84wamnts.bkt.clouddn.com/20170811-1.gif" alt="20170811-1"></p>
<p>下面我们就来一步步的实现它。<a id="more"></a></p>
<h3 id="动画拆解"><a href="#动画拆解" class="headerlink" title="动画拆解"></a>动画拆解</h3><p>做一个复杂的东西的时候，我们需要将它拆解成若干个容易实现的细节，之后在将这些细节有序的累加起来就可以实现我们最初的复杂的结构，没准当你完成的时候自己都会发出It’s amazing的感叹。</p>
<p>来看这个动画，我们发现有两个主要元素，一个是晃动水波线，一个是由于水深造成的颜色渐变。那我们得到了第一个容易实现的细节点：</p>
<p>1.水深的颜色渐变</p>
<p>晃动的水波线对我们来说似乎并不是一个简单的元素，那我们再来拆解，或许你注意到了这是一个正弦曲线的水平移动，只是这个正弦曲线稍微有点特殊，加入了一些浮动波峰和波谷的参数。那么我们得到了第二个细节点：</p>
<p>2.水波正弦曲线</p>
<p>同时也确定了第三个细节点：</p>
<p>3.正弦曲线模拟波浪参数方式</p>
<p>然后我们还有一个工作要做，就是以上元素以何种方式组织起来，这也是第四个点：</p>
<p>4.以上元素的组织方式</p>
<h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>要实现这个动画的话我们先要来谈谈第4点，因为你不能将你分解的元素有效的组织起来的话我们的动画就不能实现。其实在动画拆解的时候，我们心里就要对第4点心中有数了，这是一个慢慢积累经验的过程，当然我们可以参考别人。</p>
<p>针对于第4点，我们的实现方式是用第2点和第3点实现的曲线设置成一个mask，去遮罩一个颜色有渐变的矩形区域（第1点），这样就得到了我们想要的波浪。想要波浪动起来，我们让波浪曲线随着时间发生变化即可。要做成效果当中的三条波浪，只需要将这些元素放置3份即可，只是设置参数不同罢了。</p>
<p>下面我们来分别实现上面拆解的细节点：</p>
<p>针对第1点，我们采用<code>CAGradientLayer</code>来实现，你不仅设置它从某个颜色渐变到另外一个颜色，而且还可以设置它的渐变方向等等。下面几行代码就可以实现我们想要的效果。</p>
<pre><code>_firstGradientLayer = [CAGradientLayer layer];
_firstGradientLayer.frame = CGRectMake(0, sc_screenSize.height-(FirstWaveCenterHeight*BEI6+FirstWaveAmplitude*BEI6), sc_screenSize.width, FirstWaveCenterHeight*BEI6+FirstWaveAmplitude*BEI6);
[_firstGradientLayer setColors:[NSArray arrayWithObjects:(id)[[UIColor colorWithRed:122.0f/255.0f green:95.0f/255.0f blue:233.0f/255.0f alpha:1] CGColor],(id)[[UIColor colorWithRed:70.0f/255.0f green:221.0f/255.0f blue:220.0f/255.0f alpha:1] CGColor], nil]];
[_firstGradientLayer setStartPoint:CGPointMake(0, 0)];
[_firstGradientLayer setEndPoint:CGPointMake(0, 1)];
[self.view.layer addSublayer:_firstGradientLayer];
</code></pre><p>效果如下：</p>
<p><img src="http://o84wamnts.bkt.clouddn.com/20170811-2.png" alt="20170811-2"></p>
<p>对于第2点，就要用到我们高中的知识了，对于屏幕上的每一个x值，计算出对应的y值，并将它们连接起来。其中<code>FirstWaveSpeed*BEI6*_firstWaveTime</code>是为了让波浪曲线随时间变化，产生向右平移运动的效果，<code>_firstVariable</code>这个属性是第3点当中要实现的更好的模拟波浪效果的参数，我们下面再进行介绍。</p>
<pre><code>- (CGMutablePathRef)getFirstCurrentWavePath
{
    CGMutablePathRef path = CGPathCreateMutable();
    CGPathMoveToPoint(path, nil, 0, FirstWaveCenterHeight*BEI6);

    float y = 0.0f;

    for (float x = 0.0f; x &lt;=  sc_screenSize.width ; x++) {
        // 正弦波浪公式
        y = FirstWaveAmplitude*BEI6 + FirstWaveAmplitude*BEI6* sin(_firstWaveCircle*x-FirstWaveSpeed*BEI6*_firstWaveTime)*_firstVariable;
        CGPathAddLineToPoint(path, nil, x, y);
    }

    CGPathAddLineToPoint(path, nil, sc_screenSize.width, sc_screenSize.height);
    CGPathAddLineToPoint(path, nil, 0, sc_screenSize.height);
    CGPathCloseSubpath(path);
    return path;
}
</code></pre><p>下面我们来看3点，为了更好的模拟波浪的效果，我们需要一个曲线振幅的变化，我这里只做了简单的随时间在设定的范围内增大和变小的操作，如果想要更好的效果，可以添加更多参数来控制，当然这也需要一些物理学的知识。</p>
<pre><code>-(void)animateFirstWave
{
    if (_firstIncrease) {
        _firstVariable += 0.01;
    }else{
        _firstVariable -= 0.01;
    }

    if (_firstVariable&lt;=0.4) {
        _firstIncrease = YES;
    }

    if (_firstVariable&gt;=0.8) {
        _firstIncrease = NO;
    }
}
</code></pre><p>以上基本元素都已经准备好了，那我们来做第4点，将上述元素整合起来。我们用<code>CAShapeLayer</code>来为第1点实现的渐变色提供提供遮罩。</p>
<pre><code>_firstWaveLayer = [CAShapeLayer layer];
_firstWaveLayer.fillColor = [UIColor whiteColor].CGColor;

[_firstGradientLayer setMask:_firstWaveLayer];

//当然别忘记把我们计算好的曲线给设置上去
_firstWaveLayer.path = [self getFirstCurrentWavePath];
</code></pre><p>这样我们就得到了一个静态的波浪</p>
<p><img src="http://o84wamnts.bkt.clouddn.com/20170811-3.png" alt="20170811-3"></p>
<p>想要波浪动起来，我们要为它加入上面提到的时间变量<code>_firstWaveTime</code>，一般情况下我们加入时间变量都会采用<code>NSTimer</code>来进行计时，但是此处我们使用<code>CADisplayLink</code>来进行定时操作。为什么使用<code>CADisplayLink</code>呢，因为<code>CADisplayLink</code>的调用频率是和屏幕的刷新频率一致的，这样的话不会出现<code>NSTimer</code>那种由于和屏幕刷新时间冲突造成的渲染滞后画面卡顿的现象。</p>
<pre><code>- (void)initTimer
{
    _firstWaveDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(setWaveLayer)];
    [self setWaveLayer];
}

- (void)setWaveLayer
{
    [self firstWaveTimeCount];
    [self animateFirstWave];
    _firstWaveLayer.path = [self getFirstCurrentWavePath];
}

//_firstCircleTime是波浪的一个时间周期，超过一个时间周期，重复上个周期的操作。
//为了了方便设置波浪的方便设置设置波浪的的速度和周期引入的此参数。
- (void)firstWaveTimeCount
{
    _firstWaveTime++;
    _firstWaveTime = _firstWaveTime%_firstCircleTime;
}
</code></pre><p>这样我们就得到了第一个流动的波浪</p>
<p><img src="http://o84wamnts.bkt.clouddn.com/20170811-4.gif" alt="20170811-4"></p>
<p>下面只要在重复添加两条线就可以得到我们想要的效果了，不过，需要注意的是第三条波浪的颜色渐变是从左到右的哦，当然这是一个小问题。</p>
<h3 id="动画调整"><a href="#动画调整" class="headerlink" title="动画调整"></a>动画调整</h3><p>大部分情况下，我们写出来的复杂动画都会和设计师想要的样子有一定差距，当然也不排除能拿到精准参数的情况，但毕竟让一个设计师告诉你正弦曲线的起始位置不太现实，这个时候我们需要把能控制这个动画的一些参数单独写出来，不要用写死的值，其他的参数依赖于这些值，由这些值计算出来。这样我们就可以方便的调整动画的显示了，甚至可以让设计师自己动手调整出想要的样子。</p>
<pre><code>const static float FirstWaveCenterHeight = 162;
const static float FirstWaveAmplitude = 20.0f;//振幅比例
const static float FirstWaveNum = 1;//容纳曲线循环个数
const static float FirstWaveSpeed = 0.05f;//波浪速度
</code></pre><p>源码：<a href="https://github.com/yangzq007/SHDemo" target="_blank" rel="external">https://github.com/yangzq007/SHDemo</a>-&gt;水波动画</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理文件的时候发现以前写的一个动画，感觉还不错，就和大家分享一下。&lt;/p&gt;
&lt;p&gt;如何实现一个如下图的动画呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o84wamnts.bkt.clouddn.com/20170811-1.gif&quot; alt=&quot;20170811-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我们就来一步步的实现它。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS工程文件整理</title>
    <link href="http://yoursite.com/2017/07/31/iOS%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/31/iOS工程文件整理/</id>
    <published>2017-07-31T02:17:30.000Z</published>
    <updated>2018-04-04T06:50:48.373Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发过程的当中不知道大家有没有遇到过这样的问题</p>
<ol>
<li>文件的物理位置不对应</li>
<li>多余的未被工程引用的文件</li>
</ol>
<p>这两个问题在工程变得比较大的时候，对工程的影响就比较让人难受了，于是我决定对工程进行整理。</p>
<p>因为我们的业务还是蛮复杂的，工程就特别大，手动查找和整理简直就是一场灾难，于是我决定使用脚本来帮助我完成这项虽然简单但是巨大的工程。<a id="more"></a></p>
<h3 id="文件物理位置不对应的原因"><a href="#文件物理位置不对应的原因" class="headerlink" title="文件物理位置不对应的原因"></a>文件物理位置不对应的原因</h3><p>说到这个问题，我们就需要提一下project.pbxproj文件了，对，就是那个每次合并冲突都让人头疼的文件。</p>
<p><a href="http://www.monobjc.net/xcode-project-file-format.html" target="_blank" rel="external">project.pbxproj</a>文件本质上是一种旧风格的plist，因为可读性不是很好，逐渐被弃用，但是苹果却一直沿用，在这个文件当中包含了Xcode工程的各项配置和参数。project.pbxproj文件采用UDID作为key索引来保证文件的唯一性，同时又在value当中指定其对应子节点的UDID值，这样就将一个树形结构的数据用列表形式表示了出来（UDID是根据硬件和时间戳生成的唯一标识，这里不再详细解释其过程），工程的虚拟文件目录就是这么来的。</p>
<p>下面是一个转换成标准plist的结构，我们可以看到它的引用方式</p>
<p><img src="http://o84wamnts.bkt.clouddn.com/20170731-1.png" alt="20170731-1"></p>
<p>因此我们解决物理位置不对应的问题只需要读取project.pbxproj的虚拟目录，并检查当前目录下是否有该文件，如果没有，到其对应的物理路径下，将其剪切过来即可。</p>
<p>针对第二个问题，我们可以扫描工程的整个物理目录，将每个文件去虚拟目录当中查找，如果没有被引用，直接删除即可。</p>
<h3 id="脚本的编写"><a href="#脚本的编写" class="headerlink" title="脚本的编写"></a>脚本的编写</h3><p>我们使用python来完成这次的任务，为什么不用shell？因为bash 3不支持key-value结构，要升级到bash 4才可以，而python比较方便，就使用它了，推荐使用python 3，因为它简化了蛮多操作的，比如编码什么的，不推荐使用预装的python 2。</p>
<p>1.读取project.pbxproj</p>
<p>我们先需要使用以下命令将project.pbxproj转换成标准的plist，然后使用python库<code>biplist</code>读取</p>
<pre><code>value=`plutil -convert xml1 -o - project.pbxproj` &amp;&amp; echo $value &gt;mPlistPath
</code></pre><p>2.检查虚拟目录下对应的文件是否存在，并进行相应操作</p>
<p>3.扫描工程物理路径，检查文件是否被引用，并进行操作</p>
<p>脚本如下：</p>
<pre><code># !/usr/bin/python
# coding=utf-8

from biplist import *
import os

global rootObjects
global rootArr
global plistPath

####################变量设置区#################################
rootPath= &quot;/Users/yzq/Desktop/Test/Test&quot;
projectFilePath = &quot;/Users/yzq/Desktop/Test/Test.xcodeproj&quot;
plistPath = &quot;/Users/yzq/Desktop/123.plist&quot;
##############################################################

def checkfile(filePath,filekey):
    global rootObjects

    dic = rootObjects[filekey]
    # print(filekey) 

    strPath = &quot;&quot;
    if &quot;path&quot; in dic:
        strPath = dic[&quot;path&quot;]
    else:
        strPath = dic[&quot;name&quot;]

    path = filePath + &quot;/&quot; + strPath
    if &quot;children&quot; in dic:
        if len(dic[&quot;children&quot;]) &lt; 1:
            print(&quot;空文件夹&quot;+&quot;------&quot;+path)
        else:
            for item in dic[&quot;children&quot;]:
                checkfile(path,item)
    else:
        if os.path.exists(path) == False:
            print(&quot;文件不存在&quot;+path)


def startCheckFile(mRootPath):
    global rootObjects
    global plistPath

    plist = readPlist(plistPath)
    rootObjects = plist[&quot;objects&quot;]

    for dic in rootObjects.values():
        if (&quot;name&quot; in dic) and dic[&quot;name&quot;] == &quot;dfc_v3&quot;:
            rootArr = dic[&quot;children&quot;]
            break

    print(rootArr)

    for item in rootArr:
        print(&quot;开始检查item&quot;+item+&quot;-------------------------------&quot;)
        checkfile(mRootPath,item)


def checkFileIsInProject(mPlistObject, mFileName, mFilePath):
    for item in mPlistObject.values():
        if ((&quot;path&quot; in item) and (item[&quot;path&quot;] == mFileName)) or ((&quot;name&quot; in item) and (item[&quot;name&quot;] == mFileName)):
            # print(&quot;发现文件引用&quot;+mFileName)
            return
    print(&quot;未发现文件应用：&quot;+mFileName)
    print(mFilePath)


def checkProject(mPlistObject, mFilePath):
    dirList = os.listdir(mFilePath)
    for item in dirList:
        itemPath = os.path.join(mFilePath,item)
        if os.path.isfile(itemPath):
            checkFileIsInProject(mPlistObject,item,itemPath)
        elif os.path.isdir(itemPath):
            checkProject(mPlistObject,itemPath)
        else:
            print(&quot;当前路径出错:&quot;+itemPath)


def startCheckProject(mRootPath):
    global plistPath

    plist = readPlist(plistPath)
    rootObjects = plist[&quot;objects&quot;]

    checkProject(rootObjects,mRootPath)


def getPlist(mProjectFilePath,mPlistPath):
    command = &quot;rm -rf &quot;+mPlistPath
    os.system(command)
    command = &quot;value=`plutil -convert xml1 -o - &quot;+mProjectFilePath+&quot;/project.pbxproj` &amp;&amp; echo $value &gt;&quot;+mPlistPath
    os.system(command)
    print(&quot;生成plist文件:&quot;+mPlistPath)


print(&quot;这是一个帮你检查工程文件的脚本，请输入以下数字选项执行&quot;)
print(&quot;0.准备工作&quot;)
print(&quot;1.检查工程列表当中的文件是否在对应的物理位置&quot;)
print(&quot;2.检查工程当中是否有文件未加入引用&quot;)
choice = input(&quot;请输入:&quot;)
if choice == &quot;0&quot;:
    print(&quot;请设置脚本rootPath、projectFilePath、plistPath三个变量的路径值&quot;)
    print(&quot;rootPath：工程根目录，dfc_v2的那个文件夹目录&quot;)
    print(&quot;projectFilePath：工程文件目录,dfc_v2.xcodeproj文件目录&quot;)
    print(&quot;plistPath：生成plist文件所在位置，该位置任意，具备读写权限即可&quot;)
elif choice == &quot;1&quot;:
    getPlist(projectFilePath,plistPath)
    startCheckFile(rootPath)
elif choice == &quot;2&quot;:
    getPlist(projectFilePath,plistPath)
    startCheckProject(rootPath)
else:
    print(&quot;未输入正确的操作&quot;)
</code></pre><p>因为贸然的使用脚本改动工程有一定的风险，所以我在脚本当中把有问题的文件及其目录输出，手动去改动。</p>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>执行脚本，让后根据输出的结果修改工程，因为<code>Supporting Files</code>下的文件直接是在主目录下的，它下面的文件直接忽略即可。</p>
<pre><code>python3 my.py
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程的当中不知道大家有没有遇到过这样的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件的物理位置不对应&lt;/li&gt;
&lt;li&gt;多余的未被工程引用的文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个问题在工程变得比较大的时候，对工程的影响就比较让人难受了，于是我决定对工程进行整理。&lt;/p&gt;
&lt;p&gt;因为我们的业务还是蛮复杂的，工程就特别大，手动查找和整理简直就是一场灾难，于是我决定使用脚本来帮助我完成这项虽然简单但是巨大的工程。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://yoursite.com/tags/Xcode/"/>
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>React Native之mobx绑定</title>
    <link href="http://yoursite.com/2017/07/12/React-Native%E4%B9%8Bmobx%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2017/07/12/React-Native之mobx绑定/</id>
    <published>2017-07-12T08:53:33.000Z</published>
    <updated>2018-04-04T06:52:18.171Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个iOS开发，想必大家都经历过把很多状态和逻辑放到Controller当中的时候，当Controller逐渐变大，数据处理逻辑、视图展示逻辑和状态控制逻辑混在一起会导致代码越来越难维护，RN当中的State也会存在这样的问题，我们引入mobx就是为了解决这样的问题。</p>
<blockquote>
<p>MobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。</p>
</blockquote>
<p>mobx通过响应式的结构将数据和视图的处理逻辑进行分离，比较好的解决了状态维护的问题，再将数据处理分离出去就是一个标准的MVVM的结构，开发者在VM当中对数据和视图进行了绑定后就可以只关心视图的渲染和数据的处理了，这样也更容易理解。<a id="more"></a></p>
<h3 id="mobx的使用"><a href="#mobx的使用" class="headerlink" title="mobx的使用"></a>mobx的使用</h3><p>使用前，首先我们要安装下</p>
<pre><code>npm install mobx --save
npm install mobx-react --save    //React 绑定库
</code></pre><p>然后是分别在数据绑定文件和视图文件当中中添加装饰器绑定，下面是部分示例代码</p>
<pre><code>//数据绑定文件
import { computed, observable } from &apos;mobx&apos;;

class IndexStore {
    @observable listData = [];
}

//视图文件
import { observer } from &apos;mobx-react/native&apos;;
import IndexStore from &apos;indexStore&apos;;

@observer
class Index extends Component {
    constructor() {
        super();
        this.store = new IndexStore();
    }

    render() {
    return (
        &lt;MainItem dataSource={this.store.listData}
        renderHeader={
            () =&gt; &lt;Item data={this.store}&gt;&lt;/Item&gt;
        } /&gt;
    )
}
</code></pre><h3 id="mobx的绑定过程"><a href="#mobx的绑定过程" class="headerlink" title="mobx的绑定过程"></a>mobx的绑定过程</h3><p>mobx在建立绑定时先将视图的render()走一遍，收集视图和被观察数据的关联，并将这些关联储存起来。当数据源发生变化之后，mbox就根据这些对应的关联，刷新对应的视图。</p>
<p>需要注意的是以下两种情况，对应的视图和关联不会被收集到：</p>
<p>1.赋值给属性的函数当中的关联不会在当前视图中收集</p>
<p>比如上面实例当中的renderHeader属性赋值的函数<code>() =&gt; &lt;Item data={this.store}&gt;&lt;/Item&gt;</code>，因为Item作为返回值返回，并不属于该视图当中的渲染。不过store当中的数据可以在Item当中的渲染中绑定，但需要你在Item中添加@observer.</p>
<p>2.直接使用被观察变量的值，未出现对应的引用</p>
<p>比如在Item当中添加了@observer，但是直接将被被观测变量的值赋值给了Item也是无法建立关联的，比如下面这种写法</p>
<pre><code>renderHeader={
    () =&gt; &lt;Item data={this.store.listData}&gt;&lt;/Item&gt;
}
</code></pre><p>这样被观测变量的值赋了过去，在Item的render当中并没有被观察变量引用，这样mobx认为是没有被观察数据使用的。正确的方法是像实例当中那样把被观测数据的父级引用传递过去，在Item当中使用父级引用来引用被观察变量来使用。</p>
<p>只要注意了以上两种情况，mobx的绑定基本就没有什么大问题了，接下来就是享受mobx给你带来的便利了。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>绑定建立完成后，需要注意被观察的变量引用发生变化时必须是一个新值，指向一个新的地址，直接修改变量当中的值并不会让被观察变量的值发生变化，界面并不会刷新。</p>
<pre><code>class IndexStore {
    //this.listData的值没有变化，界面不会刷新
    this.listData[0] = &quot;1&quot;;

    //this.listData是一个新值，界面刷新
    this.listData = [&quot;1&quot;];
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个iOS开发，想必大家都经历过把很多状态和逻辑放到Controller当中的时候，当Controller逐渐变大，数据处理逻辑、视图展示逻辑和状态控制逻辑混在一起会导致代码越来越难维护，RN当中的State也会存在这样的问题，我们引入mobx就是为了解决这样的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mobx通过响应式的结构将数据和视图的处理逻辑进行分离，比较好的解决了状态维护的问题，再将数据处理分离出去就是一个标准的MVVM的结构，开发者在VM当中对数据和视图进行了绑定后就可以只关心视图的渲染和数据的处理了，这样也更容易理解。
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>React Native之如何写一个ListView</title>
    <link href="http://yoursite.com/2017/07/05/React-Native%E4%B9%8B%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAListView/"/>
    <id>http://yoursite.com/2017/07/05/React-Native之如何写一个ListView/</id>
    <published>2017-07-05T03:11:43.000Z</published>
    <updated>2018-04-04T06:52:38.483Z</updated>
    
    <content type="html"><![CDATA[<p>写RN也有段时间了，今天抽空就对RN当中的ListView进行一个简单介绍，主要介绍使用当中的一些坑。</p>
<h3 id="写一个简单的ListView"><a href="#写一个简单的ListView" class="headerlink" title="写一个简单的ListView"></a>写一个简单的ListView</h3><pre><code>class MyComponent extends Component {
  constructor() {
    super();
    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2});
    this.state = {
      dataSource: ds.cloneWithRows([&apos;row 1&apos;, &apos;row 2&apos;]),
    };
  }

  render() {
    return (
      &lt;ListView
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&gt; &lt;Text&gt;{rowData}&lt;/Text&gt;}
      /&gt;
    );
  }
}
</code></pre><a id="more"></a>
<p>以上代码就可以绘制一个简单的ListView了，但是我们需要注意<code>dataSource: ds.cloneWithRows([&#39;row 1&#39;, &#39;row 2&#39;])</code>这一行，因为我们的数据一般都是网络请求来的，所以我们一般可能会写成这样</p>
<pre><code>listData = [];

constructor() {
    super();
    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2});
    this.state = {
      dataSource: ds.cloneWithRows(this.listData),
    };
  }

  ***省略的网络请求***
  listData = [&apos;row 1&apos;, &apos;row 2&apos;];
  ***省略的更新state***
</code></pre><p>然而你发现你的ListView并没有更新，还是一片空白,当我们把<code>dataSource: ds.cloneWithRows(this.listData)</code>这一行改成<code>dataSource: ds.cloneWithRows(this.listData.slice())</code>你会发现问题解决了，why?</p>
<p>这是因为这样只是一个浅拷贝，虽然数组内容发生了变化，但是<code>ds.cloneWithRows</code>接收到的数据没有发生变，故页面会刷新。当我们用<code>slice</code>时，给它返回一个新值，这样界面就会重新刷新渲染。</p>
<h3 id="写一个带Section的ListView"><a href="#写一个带Section的ListView" class="headerlink" title="写一个带Section的ListView"></a>写一个带Section的ListView</h3><p>要写一个带Section的ListView主要是针对数据源的改造。</p>
<p>DataSource构造函数可以接受下列四种参数（都是可选）：</p>
<pre><code>getRowData(dataBlob, sectionID, rowID);
getSectionHeaderData(dataBlob, sectionID);
rowHasChanged(prevRowData, nextRowData);
sectionHeaderHasChanged(prevSectionData, nextSectionData);
</code></pre><p>如果不提供getRowData和getSectionHeaderData方法，使用defaultGetRowData和defaultGetSectionHeaderData来提取数据，默认的提取函数可以处理的数据结构如下：</p>
<pre><code>{ sectionID_1: { rowID_1: rowData1, ... }, ... }
或者
{ sectionID_1: [ rowData1, rowData2, ... ], ... }
或者
[ [ rowData1, rowData2, ... ], ... ]
</code></pre><p>我们用第二种数据结构来实现：</p>
<pre><code>class MyComponent extends Component {
  constructor() {
    super();

    listData = { &quot;1&quot;: [ &quot;11&quot;, &quot;12&quot;], &quot;2&quot;: [ &quot;21&quot;, &quot;22&quot;] };

    const ds =  new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2,
        sectionHeaderHasChanged: (s1, s2) =&gt; s1 != s2
    });
    this.state = {
      dataSource: ds.cloneWithRowsAndSections(
              this.listData,
              Object.keys(this.listData),
              Object.keys(this.listData).map(
            (sectionId) =&gt; Object.keys(
                this.listData[sectionId].slice()
            )
        )
      ),
    };
  }

  render() {
    return (
      &lt;ListView
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&gt; &lt;Text&gt;{rowData}&lt;/Text&gt;}
      /&gt;
    );
  }
}
</code></pre><p>需要注意的是<code>cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities)</code>方法当中的参数也需要是一个新值，所以<code>rowIdentities</code>参数的数据也需要<code>slice()</code>一下，回传一个新值。</p>
<p>当需要将sectionHeader的样式显示出来，还需要在render当中添加关于header渲染的代码</p>
<pre><code>render() {
    return (
      &lt;ListView
           renderSectionHeader={
                (sectionData, sectionID) =&gt; &lt;Text&gt;{sectionID}&lt;/Text&gt;
        }
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&gt; &lt;Text&gt;{rowData}&lt;/Text&gt;}
      /&gt;
    );
  }
</code></pre><p>这样一个带section的ListView就写出来了。</p>
<h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><ol>
<li>React Native不支持随ListView滚动的Header，如果需要，请在每个section当中的第一个Item当中添加</li>
<li>如果ListView要下拉一下才显示出来，请设置ListView的属性<code>removeClippedSubviews={false}</code></li>
<li>如果在iOS设备上ListView距离顶部导航栏有距离，请设置ListView的属性<code>automaticallyAdjustContentInsets={false}</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写RN也有段时间了，今天抽空就对RN当中的ListView进行一个简单介绍，主要介绍使用当中的一些坑。&lt;/p&gt;
&lt;h3 id=&quot;写一个简单的ListView&quot;&gt;&lt;a href=&quot;#写一个简单的ListView&quot; class=&quot;headerlink&quot; title=&quot;写一个简单的ListView&quot;&gt;&lt;/a&gt;写一个简单的ListView&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class MyComponent extends Component {
  constructor() {
    super();
    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&amp;gt; r1 !== r2});
    this.state = {
      dataSource: ds.cloneWithRows([&amp;apos;row 1&amp;apos;, &amp;apos;row 2&amp;apos;]),
    };
  }

  render() {
    return (
      &amp;lt;ListView
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&amp;gt; &amp;lt;Text&amp;gt;{rowData}&amp;lt;/Text&amp;gt;}
      /&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>文档网站生成工具docsify</title>
    <link href="http://yoursite.com/2017/06/20/%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7docsify/"/>
    <id>http://yoursite.com/2017/06/20/文档网站生成工具docsify/</id>
    <published>2017-06-20T09:58:08.000Z</published>
    <updated>2018-04-04T06:53:04.778Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o84wamnts.bkt.clouddn.com/20170620-1.png" alt="20170620-1"></p>
<p>今天给大家推荐一个非常好用的工具docsify，对，没错，就是上面这个萌萌哒的类似果冻的东西。</p>
<h3 id="docsify"><a href="#docsify" class="headerlink" title="docsify"></a>docsify</h3><p>docsify是一个非常好用的文档网站生成工具。它能快速的将你存储在Git仓库中的markdown文档生成一个文档网站，而且界面非常美观。</p>
<p>下面是docsify文档的介绍</p>
<blockquote>
<p>docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。</p>
<p>这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>直接点击<a href="https://docsify.js.org/#/" target="_blank" rel="external">这里</a>查看其官方文档即可，里面非常详细的介绍了如何使用。另外<a href="https://docsify.js.org/#/zh-cn/" target="_blank" rel="external">docsify文档</a>也是一个实例demo。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o84wamnts.bkt.clouddn.com/20170620-1.png&quot; alt=&quot;20170620-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天给大家推荐一个非常好用的工具docsify，对，没错，就是上面这个萌萌哒的类似果冻的东西。&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS下的cookies使用</title>
    <link href="http://yoursite.com/2017/05/27/iOS%E4%B8%8B%E7%9A%84cookies%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/05/27/iOS下的cookies使用/</id>
    <published>2017-05-27T08:21:36.000Z</published>
    <updated>2018-04-04T07:01:45.987Z</updated>
    
    <content type="html"><![CDATA[<p>今天无意间翻到了以前有关cookies的代码，就顺便整理了一下，和大家分享下。</p>
<h3 id="Cookies简介"><a href="#Cookies简介" class="headerlink" title="Cookies简介"></a>Cookies简介</h3><p>这里有比较详细的介绍，本文就不再赘述了。<a href="http://blog.csdn.net/fangaoxin/article/details/6952954" target="_blank" rel="external">click me</a></p>
<p>在iOS当中需要注意以下几点：</p>
<ol>
<li>不管是NSURLConnection还是UIWebView都会保留并传递服务端的cookie，就是说基本所有的网络请求都会使用cookie</li>
<li>多个应用之间默认不共享cookie</li>
<li>临时cookie在应用重启之后就会消失</li>
<li>持久cookie在应用或系统重启之后不会消失</li>
<li>cookie不能跨域，像.baidu.com和image.baidu.com这种也是跨域</li>
<li>WKWebView因为没有缓存，不能使用cookie，想要使用，需做特殊处理。</li>
</ol>
<p>注：cookie不能跨域是通用的，在所有情况下都是这样，并非在iOS系统上如此。.baidu.com和image.baidu.com可以使用彼此的cookie是因为服务端做了特殊的处理。<a id="more"></a></p>
<h3 id="Cookies操作"><a href="#Cookies操作" class="headerlink" title="Cookies操作"></a>Cookies操作</h3><p>iOS系统当中的cookies由系统底层实现和使用，同时提供了<code>NSHTTPCookieStorage</code>和<code>NSHTTPCookie</code>来统一操作cookie。<code>NSHTTPCookieStorage</code>是一个单例，我们所有的cookies都存放在这里，当我们发起网络请求时，系统会默认从<code>NSHTTPCookieStorage</code>当中匹配相应cookie并带上去，所以我们只需要操作<code>NSHTTPCookieStorage</code>即可。</p>
<p>以下是一些简单的使用</p>
<pre><code>/**
 *  获得url对应的cookie
 *
 *  @param url url
 *
 *  @return url对应的cookie
 */
- (NSArray *)getCookiesForUrl:(NSString *)url
{
    NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

    if ([sharedHTTPCookieStorage cookieAcceptPolicy] != NSHTTPCookieAcceptPolicyAlways) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];
    }

    NSArray *cookies = [sharedHTTPCookieStorage cookiesForURL:[NSURL URLWithString:url]];

    return cookies;
}

/**
 *  获取应用下所有的cookie
 *
 *  @return 所有的cookie
 */
- (NSArray *)getAllCookies
{
    NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

    if ([sharedHTTPCookieStorage cookieAcceptPolicy] != NSHTTPCookieAcceptPolicyAlways) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];
    }

    return sharedHTTPCookieStorage.cookies;
}

/**
 *  将cookie数组当中的cookie设置到cookie缓存中
 *
 *  @param mArrCookie cookie数组
 */
- (void)setCookiesFromArr:(NSArray *)mArrCookie
{
    if (mArrCookie != nil &amp;&amp; [mArrCookie count]&gt;0) {
        NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

        for (NSHTTPCookie *cookie in mArrCookie) {
            [sharedHTTPCookieStorage setCookie:cookie];
        }
    }
}

/**
 *  为特殊的url设置cookie
 *
 *  @param mArrCookie cookie数组
 *  @param url        地址，此处地址格式需为.baidu.com这样
 */
- (void)setCookie:(NSArray *)mArrCookie forUrl:(NSString *)url
{
    if (mArrCookie != nil &amp;&amp; [mArrCookie count]&gt;0) {
        NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

        for (NSHTTPCookie *cookie in mArrCookie) {
            NSMutableDictionary *cookieDic = [NSMutableDictionary dictionaryWithDictionary:[cookie properties]];
            [cookieDic setObject:url forKey:@&quot;Domain&quot;];
            NSHTTPCookie *tempCookie = [NSHTTPCookie cookieWithProperties:cookieDic];
            [sharedHTTPCookieStorage setCookie:tempCookie];
        }
    }
}

/**
 获取特定url相应key的value值

 @param key cookie的key值
 @param url url，一个完整的url地址，例如https://www.baidu.com/
 @return 当前url下cookie当中当前key对应的value值
 */
- (NSString *)cookieValueWithKey:(NSString *)key forUrl:(NSURL *)url
{
    NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

    if ([sharedHTTPCookieStorage cookieAcceptPolicy] != NSHTTPCookieAcceptPolicyAlways) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];
    }

    NSArray *cookies = [sharedHTTPCookieStorage cookiesForURL:url];
    for (NSHTTPCookie *item in cookies) {
        if ([[item name] isEqualToString:key]) {
            return [NSString stringWithString:[[item value] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];
        }
    }
    return nil;
}

//以下是一些将cookies本地化的操作

- (void)saveCacheCookie:(id)sender {
    NSArray *mArrCookie = [self getAllCookies];
    NSData *cookieData = [NSKeyedArchiver archivedDataWithRootObject:mArrCookie];
    [[NSUserDefaults standardUserDefaults] setObject:cookieData forKey:@&quot;cookieData&quot;];
}

- (void)unzipCookie:(id)sender {
    NSData *cookieData = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;cookieData&quot;];
    NSArray *mArrCookie = [NSKeyedUnarchiver unarchiveObjectWithData:cookieData];        
    [self setCookiesFromArr:mArrCookie];
}
</code></pre><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>针对跨域问题，可以在服务器和客户端分别做处理解决</p>
<p>服务器：在服务器返回cookie时同时将相关联的其他域的cookie返回</p>
<p>客户端：在每次请求完成后，对想跨域的域名进行设置，添加对应的cookie</p>
<p>推荐在服务器配置相关策略</p>
<h3 id="WKWebView使用cookie"><a href="#WKWebView使用cookie" class="headerlink" title="WKWebView使用cookie"></a>WKWebView使用cookie</h3><p>因为WKWebView没有缓存，不使用<code>NSHTTPCookieStorage</code>，其cookie只存在内存当中，当前页面被释放其cookie也就消失了。因此WKWebView当中的请求不能使用其他请求的cookie，同时两个WKWebView页面也不共享cookie。</p>
<p>所以想要WKWebView使用其他请求的cookie或者前一个WKWebView页面的cookie需要在WKWebView加载前执行一段js代码，将cookie设置进去，而每次WKWebView请求之后获取cookie，将其保存起来。至于存在哪里，<code>NSHTTPCookieStorage</code>和<code>NSUserDefaults</code>都是不错的选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天无意间翻到了以前有关cookies的代码，就顺便整理了一下，和大家分享下。&lt;/p&gt;
&lt;h3 id=&quot;Cookies简介&quot;&gt;&lt;a href=&quot;#Cookies简介&quot; class=&quot;headerlink&quot; title=&quot;Cookies简介&quot;&gt;&lt;/a&gt;Cookies简介&lt;/h3&gt;&lt;p&gt;这里有比较详细的介绍，本文就不再赘述了。&lt;a href=&quot;http://blog.csdn.net/fangaoxin/article/details/6952954&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;click me&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在iOS当中需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不管是NSURLConnection还是UIWebView都会保留并传递服务端的cookie，就是说基本所有的网络请求都会使用cookie&lt;/li&gt;
&lt;li&gt;多个应用之间默认不共享cookie&lt;/li&gt;
&lt;li&gt;临时cookie在应用重启之后就会消失&lt;/li&gt;
&lt;li&gt;持久cookie在应用或系统重启之后不会消失&lt;/li&gt;
&lt;li&gt;cookie不能跨域，像.baidu.com和image.baidu.com这种也是跨域&lt;/li&gt;
&lt;li&gt;WKWebView因为没有缓存，不能使用cookie，想要使用，需做特殊处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：cookie不能跨域是通用的，在所有情况下都是这样，并非在iOS系统上如此。.baidu.com和image.baidu.com可以使用彼此的cookie是因为服务端做了特殊的处理。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods invalid byte sequence in UTF-8</title>
    <link href="http://yoursite.com/2017/05/26/CocoaPods-invalid-byte-sequence-in-UTF-8/"/>
    <id>http://yoursite.com/2017/05/26/CocoaPods-invalid-byte-sequence-in-UTF-8/</id>
    <published>2017-05-26T03:22:03.000Z</published>
    <updated>2018-04-04T07:04:06.827Z</updated>
    
    <content type="html"><![CDATA[<p>CocoaPods作为iOS开发常用的包管理工具一直深受大家的喜爱，但是它出现问题的时候也让我们非常纠结。最近我就遇到这么一个让人纠结的错误<code>ArgumentError - invalid byte sequence in UTF-8</code>，下面就来说下如何解决它。</p>
<p>我的问题是当你<code>pod search &lt;content&gt;</code>时就会报这个错误，详细的错误提示如下：</p>
<pre><code>/Users/yzq/.rvm/gems/ruby-2.4.1@global/gems/cocoapods-1.2.1/lib/cocoapods/user_interface/error_report.rb:135:in `error_from_podfile&apos;: invalid byte sequence in UTF-8 (ArgumentError)
</code></pre><p>期间我尝试了重新下载repo、重新安装CocoaPods、甚至重新安装Ruby环境都没有解决，手动摊手。</p>
<p>当你Google这个错误或者在CocoaPods的issues里面搜索之后，你大致会发现以下几种解决方案。</p>
<h3 id="字符集错误"><a href="#字符集错误" class="headerlink" title="字符集错误"></a>字符集错误</h3><p>这种方法认为你本地字符集没有配置好，需要配置成标准的<code>en_US.UTF-8</code>，执行以下命令即可，或者将以下命令添加的相应的shell配置文件当中，例如：~/.bashrc或者~/.zshrc。</p>
<pre><code>//使用命令locale可以查看本地字符集

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
</code></pre><p>然而这种方法并没有解决我的问题，我使用<code>locale</code>命令查看同事的电脑的字符集，发现和我一样是<code>zh_CN.UTF-8</code>，然而他的CocoaPods却没有问题，所以断定不是字符集的问题。<a id="more"></a></p>
<h3 id="Podfile文件当中字符错误"><a href="#Podfile文件当中字符错误" class="headerlink" title="Podfile文件当中字符错误"></a>Podfile文件当中字符错误</h3><p>我的错误是<code>pod search</code>时出现的，和Podfile并没有什么关系，但如果你是在<code>pod install</code>或者<code>pod update</code>时出现了这个错误，请检查一下你Podfile当中的引号或者逗号，如果你使用了文本编辑器编辑过Podfile，那么问题就可能出现在这里，毕竟我们不太会注意到文本编辑器的编码。</p>
<p>这里就有一个<a href="https://github.com/CocoaPods/CocoaPods/issues/4813" target="_blank" rel="external">案例</a>，我感觉应该有蛮多人会犯这个错误吧。</p>
<h3 id="索引文件错误"><a href="#索引文件错误" class="headerlink" title="索引文件错误"></a>索引文件错误</h3><p>以上方案都未果时，我偶然发现也可以用Homebrew安装CocoaPods，我尝试性的用它重装了一下CocoaPods，结果<code>pod search</code>时还是报错，但是错误变成了<code>incompatible character encodings: UTF-8 and ASCII-8BIT (Encoding::CompatibilityError)</code>。</p>
<p>接着我又在网上找了一下，发现了下面这么一条issue。</p>
<p><a href="https://github.com/CocoaPods/CocoaPods/issues/5338" target="_blank" rel="external">https://github.com/CocoaPods/CocoaPods/issues/5338</a></p>
<p>我按照里面的描述，删除了<code>~/Library/Caches/CocoaPods/search_index.json</code>文件，<code>pod search</code>奇迹般的可以了。</p>
<p>其中也大概提到出现这个问题的原因，可能是CocoaPods在创建索引时，我们<code>ctrl+c</code>取消了这个操作，这导致索引生成的某些字符有问题，所以我们删除索引文件，重新生成即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CocoaPods作为iOS开发常用的包管理工具一直深受大家的喜爱，但是它出现问题的时候也让我们非常纠结。最近我就遇到这么一个让人纠结的错误&lt;code&gt;ArgumentError - invalid byte sequence in UTF-8&lt;/code&gt;，下面就来说下如何解决它。&lt;/p&gt;
&lt;p&gt;我的问题是当你&lt;code&gt;pod search &amp;lt;content&amp;gt;&lt;/code&gt;时就会报这个错误，详细的错误提示如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/Users/yzq/.rvm/gems/ruby-2.4.1@global/gems/cocoapods-1.2.1/lib/cocoapods/user_interface/error_report.rb:135:in `error_from_podfile&amp;apos;: invalid byte sequence in UTF-8 (ArgumentError)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;期间我尝试了重新下载repo、重新安装CocoaPods、甚至重新安装Ruby环境都没有解决，手动摊手。&lt;/p&gt;
&lt;p&gt;当你Google这个错误或者在CocoaPods的issues里面搜索之后，你大致会发现以下几种解决方案。&lt;/p&gt;
&lt;h3 id=&quot;字符集错误&quot;&gt;&lt;a href=&quot;#字符集错误&quot; class=&quot;headerlink&quot; title=&quot;字符集错误&quot;&gt;&lt;/a&gt;字符集错误&lt;/h3&gt;&lt;p&gt;这种方法认为你本地字符集没有配置好，需要配置成标准的&lt;code&gt;en_US.UTF-8&lt;/code&gt;，执行以下命令即可，或者将以下命令添加的相应的shell配置文件当中，例如：~/.bashrc或者~/.zshrc。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//使用命令locale可以查看本地字符集

export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而这种方法并没有解决我的问题，我使用&lt;code&gt;locale&lt;/code&gt;命令查看同事的电脑的字符集，发现和我一样是&lt;code&gt;zh_CN.UTF-8&lt;/code&gt;，然而他的CocoaPods却没有问题，所以断定不是字符集的问题。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>简单说下tintColor</title>
    <link href="http://yoursite.com/2017/05/23/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8BtintColor/"/>
    <id>http://yoursite.com/2017/05/23/简单说下tintColor/</id>
    <published>2017-05-23T07:20:17.000Z</published>
    <updated>2018-04-04T07:04:13.539Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个问题，弹窗消失之后，APP导航栏的颜色变暗，弹框样式如下：</p>
<p><img src="http://o84wamnts.bkt.clouddn.com/20170523-2.png" alt="20170523-2"></p>
<p>起初以为是修改了导航栏的颜色，后来发现是导航栏着色<code>tintColor</code>渲染模式修改造成的。<a id="more"></a></p>
<h3 id="tintColor"><a href="#tintColor" class="headerlink" title="tintColor"></a>tintColor</h3><p>每个APP基本上都会有一个主色调，这个时候我们一般都会使用<code>tintColor</code>来设置。它比较明显的作用是影响系统默认的返回文字的颜色和一些操作按钮的颜色，这样可以方便的帮我们来设置主色调。</p>
<p><a href="https://developer.apple.com/reference/uikit/uiview/1622467-tintcolor?language=objc#declarations" target="_blank" rel="external">苹果的文档</a>当中是这样描述的</p>
<blockquote>
<h3 id="tintColor-1"><a href="#tintColor-1" class="headerlink" title="tintColor"></a>tintColor</h3><p>The first nondefault tint color value in the view’s hierarchy, ascending from and starting with the view itself.</p>
<h3 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h3><p>If the system cannot find a nondefault color in the hierarchy, this property’s value is a system-defined color instead.</p>
<p>If the view’s tintAdjustmentMode property’s value is UIViewTintAdjustmentModeDimmed, then the tintColor property value is automatically dimmed.</p>
<p>To refresh subview rendering when this property changes, override the tintColorDidChange method.</p>
<p>Colors that are pattern colors (as described in UIColor) are not supported.</p>
</blockquote>
<p>文档的大致意思是<code>tintColor</code>是视图层级当中的第一个非默认的着色颜色，当视图层级中不存在非默认的颜色值时，系统就会使用<code>tintColor</code>作为渲染的颜色值。当<code>tintAdjustmentMode</code>的值为<code>UIViewTintAdjustmentModeDimmed</code>时，所渲染出来的<code>tintColor</code>的颜色会变暗。</p>
<p>需要注意的一点是<code>tintColor</code>的查询是在视图层级中一次次往上的，所以你父视图的设置会影响子视图的渲染。子视图想要呈现不同的颜色时，需要设置颜色或者它自己的<code>tintColor</code>。</p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>我们上面提到的导航栏颜色变暗就是因为弹框时需要一个暗色的背景，修改了视图的的<code>tintAdjustmentMode</code>为<code>UIViewTintAdjustmentModeDimmed</code>，而在消失的时候忘记设置回默认值造成的，只需要在弹框消失时把视图的<code>tintAdjustmentMode</code>属性修改回来即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到了一个问题，弹窗消失之后，APP导航栏的颜色变暗，弹框样式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o84wamnts.bkt.clouddn.com/20170523-2.png&quot; alt=&quot;20170523-2&quot;&gt;&lt;/p&gt;
&lt;p&gt;起初以为是修改了导航栏的颜色，后来发现是导航栏着色&lt;code&gt;tintColor&lt;/code&gt;渲染模式修改造成的。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>从Signal 10 Bus Error聊聊assign和weak</title>
    <link href="http://yoursite.com/2017/04/07/%E4%BB%8ESignal-10-Bus-Error%E8%81%8A%E8%81%8Aassign%E5%92%8Cweak/"/>
    <id>http://yoursite.com/2017/04/07/从Signal-10-Bus-Error聊聊assign和weak/</id>
    <published>2017-04-07T08:42:55.000Z</published>
    <updated>2018-04-04T07:04:27.171Z</updated>
    
    <content type="html"><![CDATA[<p>曾经我以为iOS最牛叉的错误是EXC_BAD_ACCESS，直到我遇到了Signal 10 was raised. SIGBUS ……</p>
<p>这个错误出现的几率其实蛮低的，但是会造成闪退，所以还是不容忽视的。下面我们就来一起看一下</p>
<h3 id="Bus-error"><a href="#Bus-error" class="headerlink" title="Bus error"></a>Bus error</h3><p>Bus error即总线错误，以下是<a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4" target="_blank" rel="external">中文维基百科的定义</a></p>
<blockquote>
<p>存储器区块错误（英语：Segmentation fault，经常被缩写为segfault），又译为记忆段错误，也称为总线错误（bus error），或总线错误、访问权限冲突（access violation），是一种程序错误。</p>
<p>它会出现在当程序企图访问CPU无法定址的存储器区块时。当错误发生时，硬件会通知操作系统，产生了存储器访问权限冲突的状况。</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Bus_error" target="_blank" rel="external">英文维基百科的释义</a>相对详细一些，也介绍了造成这种错误的原因</p>
<blockquote>
<p>On POSIX-compliant platforms, bus errors usually result in the SIGBUS signal being sent to the process that caused the error. SIGBUS can also be caused by any general device fault that the computer detects, though a bus error rarely means that the computer hardware is physically broken—it is normally caused by a bug in a program’s source code.Bus errors may also be raised for certain other paging errors; see below.</p>
<p>There are at least three main causes of bus errors:</p>
<ul>
<li><p>Non-existent address</p>
</li>
<li><p>Unaligned access</p>
</li>
<li><p>Paging errors</p>
</li>
</ul>
</blockquote>
<a id="more"></a>
<p>上面这段话的大致意思是说在类POSIX平台，Bus errors通常是因为SIGBUS信号被发送到当前线程导致错误。SIGBUS也可以由一些硬件设备错误导致，但是这个几率极低，因此一般都是我们编码错误导致的。Bus errors也可以由特定的分页错误导致。下面是三种主要的导致Bus errors的原因，即</p>
<ul>
<li>Non-existent address（访问不存在的内存地址）</li>
<li>Unaligned access（访问未对齐的内存地址）</li>
<li>Paging errors（分页错误）</li>
</ul>
<p>看了上面的解释，我们就意识到这是一个内存访问错误了。</p>
<h3 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p>因为这个错误的出现几率不是很高，debug了挺长时间也没有进展，直到我看到了某个delegate的修饰符是assign。作为mrc时代走过来的iOS开发者刚开始对此感觉并没有什么异样，但是后来发现问题就出在这里，需要将delegate的修饰符修改为weak。</p>
<pre><code>//不安全的写法
@property (assign, nonatomic) id&lt;VinScanDelegate&gt; delegate;

//安全的写法
@property (weak, nonatomic) id&lt;VinScanDelegate&gt; delegate;
</code></pre><p>但是为什么呢？我们来看下assgin和weak的区别</p>
<h3 id="assgin-amp-weak"><a href="#assgin-amp-weak" class="headerlink" title="assgin&amp;weak"></a>assgin&amp;weak</h3><p>在arc中，assign和weak非常类似，但是他们还是有一些细微的区别的</p>
<p>weak会在所指向的对象释放消失之后自动置为nil，这样就会避免野指针导致的crash，也就不会导致上面所提到的内存错误了</p>
<blockquote>
<p>“The main difference between weak and assign is that the with weak, once the object being pointed to is no longer valid, the pointer is nilled out. Assigning the pointer the value nil avoids many crashes as messages sent to nil are essentially no-ops”</p>
</blockquote>
<p>有人写了一个小demo来验证这个问题，如下：</p>
<pre><code>#import &quot;ViewController.h&quot;

@interface ViewController ()
@property (nonatomic,weak) id weakPoint;
@property (nonatomic,assign) id assignPoint;
@property (nonatomic,strong) id strongPoint;
@end

@implementation ViewController
- (void)viewDidLoad {
    [super viewDidLoad];
    self.strongPoint = [NSDate date];
    NSLog(@&quot;strong属性：%@&quot;,self.strongPoint);
    self.weakPoint = self.strongPoint;
    self.assignPoint = self.strongPoint;
    self.strongPoint = nil;
    NSLog(@&quot;weak属性：%@&quot;,self.weakPoint);
    //NSLog(@&quot;assign属性：%@&quot;,self.assignPoint);
}
@end

//当程序中的注释被打开时，运行程序有可能会崩溃（有时候不崩溃，你可能需要多运行几次）
//这是因为当 assign 指针所指向的内存被释放（释放并不等于抹除，只是引用计数为0），不会自动赋值 nil ，
//这样再引用 self.assignPoint 就会导致野指针操作
//如果这个操作发生时内存还没有改变内容，依旧可以输出正确的结果
//而如果发生时内存内容被改变了，就会crash。
</code></pre><p>所以，在arc情况下，指针类型最好使用strong或者weak来修饰，基本类型和结构体用assign，委托要用weak来修饰。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;曾经我以为iOS最牛叉的错误是EXC_BAD_ACCESS，直到我遇到了Signal 10 was raised. SIGBUS ……&lt;/p&gt;
&lt;p&gt;这个错误出现的几率其实蛮低的，但是会造成闪退，所以还是不容忽视的。下面我们就来一起看一下&lt;/p&gt;
&lt;h3 id=&quot;Bus-error&quot;&gt;&lt;a href=&quot;#Bus-error&quot; class=&quot;headerlink&quot; title=&quot;Bus error&quot;&gt;&lt;/a&gt;Bus error&lt;/h3&gt;&lt;p&gt;Bus error即总线错误，以下是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E5%8D%80%E6%AE%B5%E9%8C%AF%E8%AA%A4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文维基百科的定义&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;存储器区块错误（英语：Segmentation fault，经常被缩写为segfault），又译为记忆段错误，也称为总线错误（bus error），或总线错误、访问权限冲突（access violation），是一种程序错误。&lt;/p&gt;
&lt;p&gt;它会出现在当程序企图访问CPU无法定址的存储器区块时。当错误发生时，硬件会通知操作系统，产生了存储器访问权限冲突的状况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bus_error&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;英文维基百科的释义&lt;/a&gt;相对详细一些，也介绍了造成这种错误的原因&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;On POSIX-compliant platforms, bus errors usually result in the SIGBUS signal being sent to the process that caused the error. SIGBUS can also be caused by any general device fault that the computer detects, though a bus error rarely means that the computer hardware is physically broken—it is normally caused by a bug in a program’s source code.Bus errors may also be raised for certain other paging errors; see below.&lt;/p&gt;
&lt;p&gt;There are at least three main causes of bus errors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Non-existent address&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unaligned access&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Paging errors&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>终端翻墙</title>
    <link href="http://yoursite.com/2017/03/29/%E7%BB%88%E7%AB%AF%E7%BF%BB%E5%A2%99/"/>
    <id>http://yoursite.com/2017/03/29/终端翻墙/</id>
    <published>2017-03-29T06:45:05.000Z</published>
    <updated>2018-04-04T07:04:33.761Z</updated>
    
    <content type="html"><![CDATA[<p>开发过程中有时候需要更新repo仓库和代码，但是GitHub上的仓库和代码的下载速度感人。</p>
<p>翻墙倒是可以解决这个问题，但是终端默认不走翻墙代理，这个时候就需要我们做一些配置了。</p>
<p>我们可以终端当中输入以下命令使终端的请求走相应的代理</p>
<pre><code>//设置http和https请求代理
export http_proxy=http://127.0.0.1:8118
export https_proxy=http://127.0.0.1:8118

//sock5协议请使用
export http_proxy=socks5://127.0.0.1:1080
export https_proxy=socks5://127.0.0.1:1080

//移除配置
unset http_proxy
unset https_proxy
</code></pre><p>我们拉取的时候有的时候可能会用到ssh，我们可以这样配置</p>
<pre><code>//设置所有协议代理
export ALL_PROXY=socks5://127.0.0.1:1080

//移除配置
unset ALL_PROXY
</code></pre><p>当前这些配置只对当前终端有效<br><a id="more"></a></p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>以上方式虽然解决了我们的需求，但是每次输入这些命令不免有些麻烦，所以我们进行了以下改进。</p>
<p>改进方案大致有以下两种：</p>
<ol>
<li>编写shell脚本，需要时运行脚本</li>
<li>自定义shell命令，简化输入</li>
</ol>
<p>相比1需要保存脚本文件来说，2是一个不错的选择</p>
<p>自定义shell命令需要你打开~/.bashrc文件（如果使用的是zsh，对应文件为.zshrc）</p>
<pre><code>//终端打开文件
open ~/.zshrc
</code></pre><p>然后在文件末尾以以下形式添加命令</p>
<pre><code>alias {自定义指令名}=&apos;{具体指令}&apos;
</code></pre><p>以上所有协议代理的命令就可以写作</p>
<pre><code>//末尾的echo是为了在命令执行完毕输出一个字符串作为提醒，可删除
alias openproxy=&quot;export ALL_PROXY=socks5://127.0.0.1:1080; echo &apos;HTTP Proxy on&apos;;&quot;
alias closeproxy=&quot;unset ALL_PROXY; echo &apos;HTTP Proxy off&apos;;&quot;
</code></pre><p>这样我们就可以使用openproxy和closeproxy方便的在终端打开和关闭代理了</p>
<h3 id="其他解决方案"><a href="#其他解决方案" class="headerlink" title="其他解决方案"></a>其他解决方案</h3><p>我们最初的目的是为了更快的从GitHub上拿到文件，同事给我提供了另外一个解决方案。</p>
<p>即对git进行相关配置，使其在请求时走代理。</p>
<p>配置需要你打开~/.gitconfig文件，在文件末尾添加</p>
<pre><code>[http &quot;https://github.com&quot;]
        proxy = socks5://127.0.0.1:1080
</code></pre><p>这样在Git发起向GitHub上的请求时就会默认走代理了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开发过程中有时候需要更新repo仓库和代码，但是GitHub上的仓库和代码的下载速度感人。&lt;/p&gt;
&lt;p&gt;翻墙倒是可以解决这个问题，但是终端默认不走翻墙代理，这个时候就需要我们做一些配置了。&lt;/p&gt;
&lt;p&gt;我们可以终端当中输入以下命令使终端的请求走相应的代理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//设置http和https请求代理
export http_proxy=http://127.0.0.1:8118
export https_proxy=http://127.0.0.1:8118

//sock5协议请使用
export http_proxy=socks5://127.0.0.1:1080
export https_proxy=socks5://127.0.0.1:1080

//移除配置
unset http_proxy
unset https_proxy
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们拉取的时候有的时候可能会用到ssh，我们可以这样配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//设置所有协议代理
export ALL_PROXY=socks5://127.0.0.1:1080

//移除配置
unset ALL_PROXY
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当前这些配置只对当前终端有效&lt;br&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用Shell脚本批量压缩图片</title>
    <link href="http://yoursite.com/2017/02/08/%E4%BD%BF%E7%94%A8Shell%E8%84%9A%E6%9C%AC%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2017/02/08/使用Shell脚本批量压缩图片/</id>
    <published>2017-02-08T09:00:03.000Z</published>
    <updated>2018-04-04T07:05:03.786Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中我们为了减小安装包的体积，我们一般会把工程当中的图片资源文件进行压缩。</p>
<p>在添加图片的时候进行压缩是一个好习惯，但是对于工程当中的大量图片进行压缩替换是一个不小的工作量，而且还有可能不小心弄错，像这种大批量的重复性工作就需要写脚本来帮助我们完成了。</p>
<h3 id="TinyPng-amp-Shell"><a href="#TinyPng-amp-Shell" class="headerlink" title="TinyPng&amp;Shell"></a>TinyPng&amp;Shell</h3><p>我们先来介绍我们今天的主角<a href="https://tinypng.com/" target="_blank" rel="external">TinyPng</a>，我相信许多开发人员都知道这个网站，TinyPng凭借着优秀的压缩效率和压缩质量备受好评。同时它也提供了相应的API供我们使用，这也是为什么要使用它的原因。</p>
<p>不过TinyPng也有一个限制，单个账号每月最多压缩500张次图片，想要提高相应压缩数量需要付费，这也对脚本的批量压缩造成了一些限制，后面会做相应介绍。</p>
<p>shell脚本就不过多的进行介绍了，网上的教程有很多，本文只会针对比较特殊的地方进行介绍。</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>基本思路是从给定的文件夹下进行遍历查找，如果是图片，进行压缩，将压缩之后的图片下载进行替换，如果是文件夹的话则进入该文件夹下进行更深一层的遍历查找压缩。具体的可以查看脚本，代码如下：<br><a id="more"></a></p>
<pre><code>#!/bin/bash

dir=&lt;#directory#&gt;

apikey=&lt;#apikey#&gt;

pngindex=0

#获取上传文件返回的数据当中的url
parse_json()
{
    value=`echo $1 | sed &apos;s/.*&quot;url&quot;:&quot;\(.*\)&quot;}}/\1/g&apos;`
    echo $value
}

compress_file()
{
    for file in `ls $1`; do
        #如果是普通文件
        if [ -f &quot;$1/$file&quot; ]; then
            if [ ${file##*.} == &quot;png&quot; ] || [ ${file##*.} == &quot;PNG&quot; ] || [ ${file##*.} == &quot;jpg&quot; ]; then
                echo &quot;压缩文件$1/$file&quot;

                s=$(curl https://api.tinify.com/shrink \
                     --user api:${apikey} \
                     --data-binary &quot;@$1/$file&quot;)

                url=$(parse_json $s) 

                #如果url不为空下载
                if [ -n &quot;$url&quot; ]; then
                    length=$(curl $url \
                         --user api:${apikey} \
                         --output &quot;$1/$file&quot;)
                else
                    echo &quot;$s1/$file压缩失败&quot;
                fi
            fi
        #如果是文件夹
        else
            compress_file &quot;$1/$file&quot;
        fi
    done
}

check_filenumber()
{
    for file in `ls $1`; do
        #如果是普通文件
        if [ -f &quot;$1/$file&quot; ]; then
            if [ ${file##*.} == &quot;png&quot; ] || [ ${file##*.} == &quot;PNG&quot; ] || [ ${file##*.} == &quot;jpg&quot; ]; then
                pngindex=`expr $pngindex + 1`
            fi
        #如果是文件夹
        else
            check_filenumber &quot;$1/$file&quot;
        fi
    done
}

main()
{
    echo &quot;请输入以下选项：&quot;
    echo &quot;0:查看当前文件夹下的png图片个数&quot;
    echo &quot;1:执行压缩操作&quot;

    read item
    if [ $item == 0 ]; then
        check_filenumber $dir
        echo &quot;图片数:$pngindex&quot;;
    elif [ $item == 1 ]; then
        compress_file $dir;
    fi
}

main
</code></pre><p><code>&lt;#directory#&gt;</code>替换成需要压缩的路径<code>&lt;#apikey#&gt;</code>替换成TinyPng上申请的key即可</p>
<p>可以看到为了避免文件夹下图片数量超过500，我先写了一个查看该文件夹下图片数量的方法，这样不想付费的用户可以使用多个账号对工程下面的图片数量不超过500进行分次压缩即可。</p>
<p>如果单个文件夹下图片超过500，建议先拆成多个小于500的文件夹进行处理。当然付费提升数量或者改造脚本也是一个不错的选择。</p>
<h3 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h3><p>1.运行脚本之前最好执行一下chmod +x &lt;#ScriptFile#&gt;命令，赋予脚本文件执行权限</p>
<p>2.shell函数一般把最后一行执行的结果作为函数的结果返回，所以<code>parse_json</code>方法最后一行的<code>echo $value</code>是将value的值返回（控制台并不输出value）。shell当中也可以使用return返回结果，但return只能返回0/1这样的整数，有一定的限制。</p>
<p>3.<code>|</code>在shell当中用来连接两个命令，并将第一个命令执行的结果作为参数传递给后面的命令</p>
<p>4.sed是流编辑器命令，用来处理获取到的文本，此处的作用是将上传返回数据当中的压缩后的图片的地址筛选出来。</p>
<p>5.`sed ‘s/&lt;#value1#&gt;/&lt;#value2#&gt;/g’``是匹配相应正则的value1用value2替换，/g表示全部替换，没有的时候只替换第一个匹配的</p>
<p>6.`sed ‘s/.<em>“url”:”(.</em>)“}}/\1/g’``当中的\1是将()当中标记为1并返回，这样value就可以接收到sed命令的处理结果。</p>
<p>7.curl是一个命令行下文件传输工具，这里不过多介绍。</p>
<p>8.之前因为不熟悉curl命令，将–dump-header &lt;#路径#&gt;添加在curl命令后，造成在<code>compress_file</code>方法当中输出s的值是正常的json数值，而在<code>parse_json</code>方法当中接收到却是网络请求头的第一行HTTP 1.1，遇到这个问题的同学注意下。</p>
<p>9.脚本文件戳<a href="https://github.com/yangzq007/mytinypng" target="_blank" rel="external">这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中我们为了减小安装包的体积，我们一般会把工程当中的图片资源文件进行压缩。&lt;/p&gt;
&lt;p&gt;在添加图片的时候进行压缩是一个好习惯，但是对于工程当中的大量图片进行压缩替换是一个不小的工作量，而且还有可能不小心弄错，像这种大批量的重复性工作就需要写脚本来帮助我们完成了。&lt;/p&gt;
&lt;h3 id=&quot;TinyPng-amp-Shell&quot;&gt;&lt;a href=&quot;#TinyPng-amp-Shell&quot; class=&quot;headerlink&quot; title=&quot;TinyPng&amp;amp;Shell&quot;&gt;&lt;/a&gt;TinyPng&amp;amp;Shell&lt;/h3&gt;&lt;p&gt;我们先来介绍我们今天的主角&lt;a href=&quot;https://tinypng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TinyPng&lt;/a&gt;，我相信许多开发人员都知道这个网站，TinyPng凭借着优秀的压缩效率和压缩质量备受好评。同时它也提供了相应的API供我们使用，这也是为什么要使用它的原因。&lt;/p&gt;
&lt;p&gt;不过TinyPng也有一个限制，单个账号每月最多压缩500张次图片，想要提高相应压缩数量需要付费，这也对脚本的批量压缩造成了一些限制，后面会做相应介绍。&lt;/p&gt;
&lt;p&gt;shell脚本就不过多的进行介绍了，网上的教程有很多，本文只会针对比较特殊的地方进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;&lt;a href=&quot;#实现思路&quot; class=&quot;headerlink&quot; title=&quot;实现思路&quot;&gt;&lt;/a&gt;实现思路&lt;/h3&gt;&lt;p&gt;基本思路是从给定的文件夹下进行遍历查找，如果是图片，进行压缩，将压缩之后的图片下载进行替换，如果是文件夹的话则进入该文件夹下进行更深一层的遍历查找压缩。具体的可以查看脚本，代码如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>JSPatch的一些坑</title>
    <link href="http://yoursite.com/2017/02/08/JSPatch%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
    <id>http://yoursite.com/2017/02/08/JSPatch的一些坑/</id>
    <published>2017-02-08T06:50:56.000Z</published>
    <updated>2018-04-04T07:04:45.585Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用JSPatch遇到了一些坑，发出来大家引以为鉴少走弯路吧，后续遇到问题的话会持续更新的。</p>
<h3 id="2017-02-08更新"><a href="#2017-02-08更新" class="headerlink" title="2017.02.08更新"></a>2017.02.08更新</h3><p>1.一些无法直接调用的常量应该怎么写，特别是系统定义的？</p>
<p>使用NSLog将对应常量值输出，直接使用输出的常量值替代<br><br>2.在JS当中发现不能调用方法，导致JS文件执行中断，使用console.log输出，发现为[NSObject object]</p>
<p>这种情况说明当前对象没有序列化，需转换成JS对象使用，调用toJS()即可</p>
<pre><code>var temp = registrationID.toJS();
</code></pre><p>更多问题详见JSPatch官方文档，<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95" target="_blank" rel="external">JSPatch 基础用法</a>，<a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98" target="_blank" rel="external">JSPatch 常见问题</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用JSPatch遇到了一些坑，发出来大家引以为鉴少走弯路吧，后续遇到问题的话会持续更新的。&lt;/p&gt;
&lt;h3 id=&quot;2017-02-08更新&quot;&gt;&lt;a href=&quot;#2017-02-08更新&quot; class=&quot;headerlink&quot; title=&quot;2017.02.08更新
    
    </summary>
    
    
      <category term="那些坑" scheme="http://yoursite.com/tags/%E9%82%A3%E4%BA%9B%E5%9D%91/"/>
    
      <category term="热修复" scheme="http://yoursite.com/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>移除SourceTree无用远程分支</title>
    <link href="http://yoursite.com/2017/02/06/%E7%A7%BB%E9%99%A4SourceTree%E6%97%A0%E7%94%A8%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"/>
    <id>http://yoursite.com/2017/02/06/移除SourceTree无用远程分支/</id>
    <published>2017-02-06T02:25:57.000Z</published>
    <updated>2018-04-04T07:04:52.001Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中我们很多时候都需要将当前分支推送到远程仓库，该分支完成其使命之后再将其删除。</p>
<p>使用SourceTree的同学可能会发现SourceTree追踪的远端分支越来越多，许多已经删除的分支也还在，即使从origin拉取也不行。</p>
<p><img src="http://o84wamnts.bkt.clouddn.com/20170206-3.png?imageView2/2/h/500/interlace/0/q/100" alt="20170206-1"></p>
<p>虽然这些不影响正常的使用，但想快速的找到一个分支还是有点麻烦的，于是我们决定清除它们。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li>进入对应目录下，使用<code>git remote show origin</code>命令查看本地仓库追踪远程仓库的状态<br><img src="http://o84wamnts.bkt.clouddn.com/20170206-2.png" alt="20170206-2"></li>
<li>使用<code>git remote prune origin</code>清除所有失效的远程分支或根据提示删除特定失效分支</li>
<li>重启SourceTree即可。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中我们很多时候都需要将当前分支推送到远程仓库，该分支完成其使命之后再将其删除。&lt;/p&gt;
&lt;p&gt;使用SourceTree的同学可能会发现SourceTree追踪的远端分支越来越多，许多已经删除的分支也还在，即使从origin拉取也不行。&lt;/p&gt;
&lt;p&gt;&lt;img sr
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>2016年个人总结</title>
    <link href="http://yoursite.com/2017/01/22/2016%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/01/22/2016年个人总结/</id>
    <published>2017-01-22T09:26:29.000Z</published>
    <updated>2018-04-04T07:05:23.498Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://o84wamnts.bkt.clouddn.com/20170122-1.JPG" alt="20170122-1"></p>
<p>一转眼马上要过春节了，趁着这个时候我也发个2016年的总结吧，给今年划上一个圆满的句号。<a id="more"></a></p>
<h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>今年经历了一次工作变动，算是意料之外的，这次变动整体上没有造成特别大的影响，自己也从这次经历当中学到了很多。</p>
<p>在今年的工作当中结识了很多有意思的小伙伴，也经历了很多有趣的事情。之前公司的小伙伴能经常聚下，这也实在是一件难得的事情，现在一起相处的同事和朋友也都非常友好和有才华，让我从不同的角度了解这个世界，挺好。</p>
<p>同事有句话说的很好</p>
<blockquote>
<p>聚是一团火,散是满天星。</p>
</blockquote>
<p>工作内容上主要还是以基础开发为主，对安全和直播这两块的涉及还是蛮让人振奋的，在脚本和架构方面的一些拓展也算是达成了自己进阶的一部分计划。</p>
<h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>生活依旧是平淡无奇的大日常。</p>
<p>好的方面：</p>
<p>加强了锻炼，经常参加各种体育活动，户外活动还是蛮多的。</p>
<p>坏的方面：</p>
<p>作息不太规律，这个好像是通病，在努力调整中。</p>
<p>今年杭城开了G20，我也刚好趁着这个假期去了云南，体验了那里的山清水秀，也算是完成了自己的一个小心愿。至于后来的黄山之行算是个小惊喜吧。</p>
<h3 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h3><ul>
<li>《平凡的世界》</li>
<li>《活着》</li>
<li>《追风筝的人》</li>
<li>《围城》</li>
<li>《人生》</li>
<li>《圣经的故事》</li>
<li>《解忧杂货店》</li>
</ul>
<p>老实说，能完成这样的阅读量有点出乎我的意料，也因为这些书籍让我对历史和宗教产生了一些的兴趣。</p>
<h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>博客是15年末16年初慢慢搭建起来的，已经走过了一个完整的年头，在这里也希望自己能够继续坚持下去，更多的分享自己的体会和心得。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://o84wamnts.bkt.clouddn.com/20170122-1.JPG&quot; alt=&quot;20170122-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;一转眼马上要过春节了，趁着这个时候我也发个2016年的总结吧，给今年划上一个圆满的句号。
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
