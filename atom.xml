<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那片树海</title>
  
  <subtitle>用心做一件工艺品</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-06T07:07:47.011Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>树海</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>切换各种源</title>
    <link href="http://yoursite.com/2020/04/28/%E5%88%87%E6%8D%A2%E5%90%84%E7%A7%8D%E6%BA%90/"/>
    <id>http://yoursite.com/2020/04/28/切换各种源/</id>
    <published>2020-04-28T09:41:43.000Z</published>
    <updated>2020-05-06T07:07:47.011Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用一些工具的时候因为他们的服务或者资源托管在国外的服务器上，会导致我们请求或者下载的速度非常慢，这是一种非常不好的体验，切换相关镜像源使用国内的服务可以极大改善这种情况。</p><h3 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h3><pre><code>替换brew.git:cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.ustc.edu.cn/brew.git替换homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git重置brew.git:cd &quot;$(brew --repo)&quot;git remote set-url origin https://github.com/Homebrew/brew.git重置homebrew-core.git:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://github.com/Homebrew/homebrew-core.git</code></pre><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><p>gem</p><pre><code>//查看源gem sources -l//添加源gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org///移除源gem sources --remove https://rubygems.org/</code></pre><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>nvm</p><pre><code>//切换源-临时设置源export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodenvm install node//切换源-将源作为参数传递进去NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install 4.2//切换源-将源变量添加到bash当中（zsh同理）echo -e &quot;\nexport NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc</code></pre><p>npm</p><pre><code>//查看源npm config -g get registry//切换源npm config -g set registry https://registry.npm.taobao.org</code></pre><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Ubuntu下载镜像<br><a href="http://mirrors.aliyun.com/ubuntu-releases/" target="_blank" rel="noopener">http://mirrors.aliyun.com/ubuntu-releases/</a></p><p>其他OS镜像，可自行查阅阿里云官方镜像站<br><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/</a></p><h3 id="镜像站"><a href="#镜像站" class="headerlink" title="镜像站"></a>镜像站</h3><p>阿里云官方镜像站<br><a href="https://developer.aliyun.com/mirror/" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在使用一些工具的时候因为他们的服务或者资源托管在国外的服务器上，会导致我们请求或者下载的速度非常慢，这是一种非常不好的体验，切换相关镜像源使用国内的服务可以极大改善这种情况。&lt;/p&gt;
&lt;h3 id=&quot;Homebrew&quot;&gt;&lt;a href=&quot;#Homebrew&quot; class
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>macOS 10.15.4下Sketch等三方软件无法打开</title>
    <link href="http://yoursite.com/2020/04/28/macOS-10.15.4%E4%B8%8BSketch%E7%AD%89%E4%B8%89%E6%96%B9%E8%BD%AF%E4%BB%B6%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80/"/>
    <id>http://yoursite.com/2020/04/28/macOS-10.15.4下Sketch等三方软件无法打开/</id>
    <published>2020-04-28T08:07:44.000Z</published>
    <updated>2020-04-28T06:06:33.202Z</updated>
    
    <content type="html"><![CDATA[<p>电脑更新macOS Catalina 10.15.4之后，原来安装的Sketch、CleanMyMac等第三方软件打不开了，直接崩溃</p><p>解决方案：打开终端，执行如下命令</p><pre><code>xattr -cr /Applications/xxx.appcodesign --force --deep --sign - /Applications/xxx.app</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;电脑更新macOS Catalina 10.15.4之后，原来安装的Sketch、CleanMyMac等第三方软件打不开了，直接崩溃&lt;/p&gt;
&lt;p&gt;解决方案：打开终端，执行如下命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xattr -cr /Applications/xxx.app
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>YCode工具集</title>
    <link href="http://yoursite.com/2019/09/10/YCode%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <id>http://yoursite.com/2019/09/10/YCode工具集/</id>
    <published>2019-09-10T12:15:56.000Z</published>
    <updated>2019-09-11T03:32:40.335Z</updated>
    
    <content type="html"><![CDATA[<p>最近在新的团队中各个团队的不同的代码风格对协作造成了较大的影响，然后就想除了人工方式能不能用工具的方式来使大家的代码风格统一，于是就写了YCode这个工具集。</p><p>YCode目前只提供代码段功能，后续会加入代码模板功能，如果大家有什么想法或者想要的功能，也可以给我提issue或者发邮件，我会慢慢完善的。如果你觉得YCode确实对你的工作有所帮助，能点个star或者推荐给其他人就更好了，多谢大家。</p><p><a href="https://github.com/yangzq007/YCode" target="_blank" rel="noopener">YCode地址</a><br><a href="https://github.com/yangzq007/CodeSnippets" target="_blank" rel="noopener">代码段仓库地址</a></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="Xcode代码段"><a href="#Xcode代码段" class="headerlink" title="Xcode代码段"></a>Xcode代码段</h4><p>安装之后就可以使用已经写好的代码段了，比如你在Xcode当中输入<code>yLazyUILabel</code>，就可以得到现成的一整段代码，具体提供的片段可以在<a href="https://github.com/yangzq007/CodeSnippets" target="_blank" rel="noopener">代码段仓库地址</a>或者Xcode当中查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在新的团队中各个团队的不同的代码风格对协作造成了较大的影响，然后就想除了人工方式能不能用工具的方式来使大家的代码风格统一，于是就写了YCode这个工具集。&lt;/p&gt;
&lt;p&gt;YCode目前只提供代码段功能，后续会加入代码模板功能，如果大家有什么想法或者想要的功能，也可以给我
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>应用程序无法打开或文件损坏</title>
    <link href="http://yoursite.com/2019/05/27/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F/"/>
    <id>http://yoursite.com/2019/05/27/应用程序无法打开或文件损坏/</id>
    <published>2019-05-27T08:07:44.000Z</published>
    <updated>2019-11-27T09:16:40.364Z</updated>
    
    <content type="html"><![CDATA[<p>Mac在使用非App Store下载的应用时，经常会遇到提示 ““xxx.app”已损坏，打不开。您应该将它移动到废纸篓” 或者 “打不开“xxx.app”，因为它来自身份不明的开发者”。</p><p>解决方案：将 “系统偏好设置-&gt;安全性与隐私-&gt;通用” 下面的 “允许从以下位置下载的App” 修改为 “任何来源”</p><p>问题1：不能修改设置<br>点击安全性与隐私面板左下角的 “🔐点按锁按钮以进行更改”，输入电脑管理员密码，即可修改</p><p>问题2：“允许从以下位置下载的App” 下没有 “任何来源” 选项<br>打开终端，输入<code>sudo spctl --master-disable</code>回车，然后输入电脑管理员密码回车执行，就可以在设置面板上看到 “任何来源” 选项了</p><p>问题3：提示 “无法打开“xxx”，因为无法确认开发者的身份”<br>右键应用程序、打开或者按住control点击应用程序</p><p>问题4：已经开启任何来源，但还是打不开（macOS Catalina 10.15以上会遇到）<br>打开终端，输入以下命令<code>sudo xattr -d com.apple.quarantine /Applications/xxxx.app</code>，重启应用即可。<br>如果应用名字有空格，请在命令当中转义，或者先修改应用程序名称，可以打开后再改回来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mac在使用非App Store下载的应用时，经常会遇到提示 ““xxx.app”已损坏，打不开。您应该将它移动到废纸篓” 或者 “打不开“xxx.app”，因为它来自身份不明的开发者”。&lt;/p&gt;
&lt;p&gt;解决方案：将 “系统偏好设置-&amp;gt;安全性与隐私-&amp;gt;通用” 下
      
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何绘制好iPhone上的1像素</title>
    <link href="http://yoursite.com/2019/04/02/%E5%A6%82%E4%BD%95%E7%BB%98%E5%88%B6%E5%A5%BDiPhone%E4%B8%8A%E7%9A%841%E5%83%8F%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/04/02/如何绘制好iPhone上的1像素/</id>
    <published>2019-04-02T07:51:24.000Z</published>
    <updated>2020-05-06T07:03:53.930Z</updated>
    
    <content type="html"><![CDATA[<p>最近在开发过程中遇到了一个问题，就是当我用22.1999…的约束（请注意这里是约束）设置一个CollectionView的左右边距时，在iPhone 8和iPhone X上绘制出来的左边分别为22和22.33，这微小的数值差距，导致了本该显示4个元素的CollectionView在iPhone X上只显示了3个，问题实例看<a href="https://github.com/yangzq007/SHDemo" target="_blank" rel="noopener">这里</a>。</p><h3 id="为什么变成了22和22-33"><a href="#为什么变成了22和22-33" class="headerlink" title="为什么变成了22和22.33"></a>为什么变成了22和22.33</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">iPhone 8</th><th style="text-align:center">iPhone X</th></tr></thead><tbody><tr><td style="text-align:center">UIKit Size</td><td style="text-align:center">375*667</td><td style="text-align:center">375*812</td></tr><tr><td style="text-align:center">分辨率</td><td style="text-align:center">750*1334</td><td style="text-align:center">1125*2436</td></tr><tr><td style="text-align:center">UIKit Scale factor</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr></tbody></table><a id="more"></a><p>由上面的表格我们可以看出，iPhone 8和iPhone X在UIKit Size的宽度上并没有什么不同，不同的点在于由分辨率导致的倍率上，iPhone 8是2，iPhone X是3。那也就是说在iPhone 8上，UIKit Size上横向的1代表着屏幕上横向的2个像素，反过来说就是，在iPhone 8上，1个像素对应的数值为0.5，也就是说iPhone 8上最小的绘制单位是0.5，那么同理，在iPhone X上最小的绘制单位是0.33。</p><p>iOS系统的针对像素的绘制采用四舍五入的方式，比如说22.1999…的小数位0.1999，在iPhone 8上相对于1个像素的基础数值为<code>0.1999/0.5=0.3998</code>，<code>0.3998&lt;0.5</code>，丢弃，故实际显示的数值为22。在iPhone X上0.1999相对于一个像素的基础数值为<code>0.1999/0.33=0.60575756</code>，<code>0.60575756&gt;0.5</code>，补充为1个像素，故在实际显示的数值为22.33，正是因为这个机制导致的微小差异使视图在不同的机型上显示出了差异。</p><h3 id="为什么是约束"><a href="#为什么是约束" class="headerlink" title="为什么是约束"></a>为什么是约束</h3><p>细心的同学可能发现，如果我直接使用frame进行布局，并不会有这样的异常，为什么在使用约束的时候会出现？</p><p>这是因为frame是你直接计算好后对应到屏幕上的，在有数值丢弃的位置刚好有相应的数值补充，这样就维持了一个平衡，导致总体占用的像素数不变。</p><p>约束采用的是先确定父视图的展示frame，然后子视图再根据父视图的frame和约束去计算自身要展示的frame，这里要注意的是父视图frame当中补充或者丢弃的部分在子视图或者其他同级的视图当中并没有对应的数值补充，这样就导致了这四舍五入引入的微小差距保留了下来，进而可能导致视图异常。</p><h3 id="如何绘制好1像素"><a href="#如何绘制好1像素" class="headerlink" title="如何绘制好1像素"></a>如何绘制好1像素</h3><ol><li>综合考虑的情况下尽量使用frame布局</li><li>2倍屏幕的1像素是0.5，3倍的屏幕是0.33，建议做区分</li><li>针对文中提到的偏差问题，建议视情况丢弃部分小数位</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>部分计算为了方便省去了靠后的小数位，不影响计算结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在开发过程中遇到了一个问题，就是当我用22.1999…的约束（请注意这里是约束）设置一个CollectionView的左右边距时，在iPhone 8和iPhone X上绘制出来的左边分别为22和22.33，这微小的数值差距，导致了本该显示4个元素的CollectionView在iPhone X上只显示了3个，问题实例看&lt;a href=&quot;https://github.com/yangzq007/SHDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么变成了22和22-33&quot;&gt;&lt;a href=&quot;#为什么变成了22和22-33&quot; class=&quot;headerlink&quot; title=&quot;为什么变成了22和22.33&quot;&gt;&lt;/a&gt;为什么变成了22和22.33&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;iPhone 8&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;iPhone X&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;UIKit Size&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;375*667&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;375*812&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;分辨率&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;750*1334&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1125*2436&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;UIKit Scale factor&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;2&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods的AppIcon错误</title>
    <link href="http://yoursite.com/2019/03/15/CocoaPods%E7%9A%84AppIcon%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2019/03/15/CocoaPods的AppIcon错误/</id>
    <published>2019-03-15T06:17:58.000Z</published>
    <updated>2019-11-27T08:12:15.009Z</updated>
    
    <content type="html"><![CDATA[<p>不知道大家在<code>pod sepc lint</code>或者<code>pod repo push</code>验证或者推自己的podspec时有没有遇到这个错误</p><pre><code>error: None of the input catalogs contained a matching stickers icon set or app icon set named &quot;AppIcon&quot;</code></pre><p>当初我使用的还是1.4.0的版本，要使用一个新特性，更新到了1.5.x，结果报了上面的错误，本来以为会在后面的版本当中修复，结果在1.5.x和1.6.x的版本中都没有解决，现在有1.7.0的beta版了，不知道这个问题修复没有，等release版本发布之后去看下。那我们要怎么度过这段艰难的时期呢，大致有以下几种方案：</p><ol><li>拿到podspec文件强推到podspec仓库</li><li>注掉CocoaPods校验逻辑</li><li>在你的pod当中添加一个冗余的Images.xcassets</li><li>不同版本的CocoaPods配合使用<a id="more"></a></li></ol><p>第1、2两种解决方案简单粗暴且有效，应急可以偶尔使用，但不推荐，第3种解决方案会造成文件冗余，建议不要使用。第4种解决方案强烈推荐，你只需安装两个版本的CocoaPods，然后在使用时通过命令控制调用不同的版本即可，大致操作如下：</p><pre><code>//安装校验不报错的1.4.0版本gem install cocoapods --version 1.4.0//调用1.4.0版本的命令pod _1.4.0_ repo push</code></pre><p>这样就完美解决了在使用新版本时校验不通过的问题了。</p><p>当我们安装了两个版本的CocoaPods时，默认会调用高版本的那个</p><pre><code>pod --version//输出1.6.1</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道大家在&lt;code&gt;pod sepc lint&lt;/code&gt;或者&lt;code&gt;pod repo push&lt;/code&gt;验证或者推自己的podspec时有没有遇到这个错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error: None of the input catalogs contained a matching stickers icon set or app icon set named &amp;quot;AppIcon&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当初我使用的还是1.4.0的版本，要使用一个新特性，更新到了1.5.x，结果报了上面的错误，本来以为会在后面的版本当中修复，结果在1.5.x和1.6.x的版本中都没有解决，现在有1.7.0的beta版了，不知道这个问题修复没有，等release版本发布之后去看下。那我们要怎么度过这段艰难的时期呢，大致有以下几种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拿到podspec文件强推到podspec仓库&lt;/li&gt;
&lt;li&gt;注掉CocoaPods校验逻辑&lt;/li&gt;
&lt;li&gt;在你的pod当中添加一个冗余的Images.xcassets&lt;/li&gt;
&lt;li&gt;不同版本的CocoaPods配合使用
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>给你的哈希算法加点“盐”</title>
    <link href="http://yoursite.com/2019/03/15/%E7%BB%99%E4%BD%A0%E7%9A%84%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E5%8A%A0%E7%82%B9%E2%80%9C%E7%9B%90%E2%80%9D/"/>
    <id>http://yoursite.com/2019/03/15/给你的哈希算法加点“盐”/</id>
    <published>2019-03-15T03:12:48.000Z</published>
    <updated>2019-03-15T07:05:45.663Z</updated>
    
    <content type="html"><![CDATA[<p>我们在平常的开发过程中为了保证信息的完整性以及安全性，我们通常都会对信息进行哈希计算签名，然后比对签名信息。</p><p>但是黑客可以通过<a href="https://baike.baidu.com/item/%E5%BD%A9%E8%99%B9%E8%A1%A8" target="_blank" rel="noopener">彩虹表</a>反推原始输入，为了增加黑客的破解难度，我们会对原始输入做一些处理，通常的做法是加入另外一个输入（也就是盐）混淆，以sha1为例，大概是<code>sha1(message+salt)</code>这个样子。</p><p>注：message+salt并不是表示字符串拼接，是表示经过特定的计算或者字符组合。</p><p>Hmac算法（Keyed-Hashing for Message Authentication）是一个将盐加入哈希计算的标准算法，它会在计算过程中将salt混入计算过程中，而且它针对所有的哈希算法都通用，相比较我们自己的实现更标准也更安全。<a id="more"></a></p><p>系统也为我们提供了相关API，我们仍以sha1算法为例，不加盐的调用如下：</p><pre><code>#import &quot;NSString+Encryption.h&quot;#import &lt;CommonCrypto/CommonDigest.h&gt;#import &lt;CommonCrypto/CommonHMAC.h&gt;- (NSString *)sha1{    NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding];    uint8_t digest[CC_SHA1_DIGEST_LENGTH];    CC_SHA1(data.bytes, (unsigned int)data.length, digest);    NSMutableString *output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH*2];    for (int i = 0; i &lt; CC_SHA1_DIGEST_LENGTH; i++) {        [output appendFormat:@&quot;%02x&quot;,digest[i]];    }    return output;}</code></pre><p>加盐的调用如下：</p><pre><code>#import &quot;NSString+Encryption.h&quot;#import &lt;CommonCrypto/CommonDigest.h&gt;#import &lt;CommonCrypto/CommonHMAC.h&gt;- (NSString *)hmacSha1:(NSString *)key{    NSData *data = [self dataUsingEncoding:NSUTF8StringEncoding];    const char *cKey = [key cStringUsingEncoding:NSUTF8StringEncoding];    unsigned char *digest = malloc(CC_SHA1_DIGEST_LENGTH);    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), [data bytes], [data length], digest);    NSData *desData = [NSData dataWithBytes:digest length:CC_SHA1_DIGEST_LENGTH];    return [desData base64EncodedStringWithOptions:0];}</code></pre><p>其他的算法也可以找到相关的API，这里就不再赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在平常的开发过程中为了保证信息的完整性以及安全性，我们通常都会对信息进行哈希计算签名，然后比对签名信息。&lt;/p&gt;
&lt;p&gt;但是黑客可以通过&lt;a href=&quot;https://baike.baidu.com/item/%E5%BD%A9%E8%99%B9%E8%A1%A8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;彩虹表&lt;/a&gt;反推原始输入，为了增加黑客的破解难度，我们会对原始输入做一些处理，通常的做法是加入另外一个输入（也就是盐）混淆，以sha1为例，大概是&lt;code&gt;sha1(message+salt)&lt;/code&gt;这个样子。&lt;/p&gt;
&lt;p&gt;注：message+salt并不是表示字符串拼接，是表示经过特定的计算或者字符组合。&lt;/p&gt;
&lt;p&gt;Hmac算法（Keyed-Hashing for Message Authentication）是一个将盐加入哈希计算的标准算法，它会在计算过程中将salt混入计算过程中，而且它针对所有的哈希算法都通用，相比较我们自己的实现更标准也更安全。
    
    </summary>
    
    
      <category term="安全加密" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2018年个人总结</title>
    <link href="http://yoursite.com/2019/01/28/2018%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/28/2018年个人总结/</id>
    <published>2019-01-28T06:20:29.000Z</published>
    <updated>2019-01-28T09:00:01.824Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190128-1.JPG" alt="20190128-1"></p><a id="more"></a><p>作为一个中国人，感觉农历春节不过好像就不算过年，所以在离春节放假前的这几天才来做2018年的个人总结。</p><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>工作内容：</p><ul><li>日常原生维护</li><li>ReactNative跨平台开发</li><li>公司业务架构的整理和优化</li><li>持续集成平台的搭建</li><li>线上保障平台的搭建</li><li>iot平台设计</li></ul><p>19年计划：</p><ul><li>架构及平台设计能力</li><li>安全及逆向</li></ul><p>今年的工作内容有挺大的跨度，年初那参加了一个较大的项目之后，便慢慢开始做业务架构和平台搭建方面的工作，在技术和思想上收获挺多的，也让自己有了许多新的认知。逆向这块去年有所涉及，但是不够深入，希望19年自己在空闲时间能在逆向及安全这块多一些了解。</p><h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>好的方面：</p><p>比以往有更清晰的目标<br>作息规律了不少</p><p>坏的方面：</p><p>最近收纳的习惯不好<br>体育锻炼及户外活动比较少</p><h3 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h3><ul><li>《三体》三部曲</li><li>《流浪地球》</li><li>《亲密关系》</li></ul><h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>今年发现挺多博客停更的，这个好习惯我希望自己能坚持下来，希望自己将来能很自豪的回看这一篇篇的文章。博客内容会继续以比较实用的内容和开发过程当中碰到的问题为主，当然也有可能会添加一些形而上的介绍之类的。</p><h3 id="其他感慨"><a href="#其他感慨" class="headerlink" title="其他感慨"></a>其他感慨</h3><p>年初从业务当中脱离出来之后就一直在搞业务架构和平台相关的东西，感觉这一年在内容上跑的太快，很容易就忽略了一些本质上的东西，我们给自己的定位是什么？我们想要什么？又能给予什么？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190128-1.JPG&quot; alt=&quot;20190128-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>iOS单元测试-各种问题</title>
    <link href="http://yoursite.com/2019/01/09/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/09/iOS单元测试-各种问题/</id>
    <published>2019-01-09T08:09:57.000Z</published>
    <updated>2019-04-02T07:54:46.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编写用例时注意"><a href="#编写用例时注意" class="headerlink" title="编写用例时注意"></a>编写用例时注意</h3><p>1.用例只针对SDK对外开放的入口</p><p>2.注意异常情况和边界值</p><p>3.注意用例之间的依赖情况</p><h3 id="单测用例如何按照顺序执行"><a href="#单测用例如何按照顺序执行" class="headerlink" title="单测用例如何按照顺序执行"></a>单测用例如何按照顺序执行</h3><p>测试函数的执行顺序与测试的字符大小有关系，如- (void)test001Example &gt; - (void)test002Example &gt; - (void)testExample</p><p>理论上单元测试不应该控制用例的执行顺序，每个case都能够单独执行，但是针对某些特殊的情况，可以适当使用一次此特性。<a id="more"></a></p><h3 id="用例依赖的情况如何处理"><a href="#用例依赖的情况如何处理" class="headerlink" title="用例依赖的情况如何处理"></a>用例依赖的情况如何处理</h3><p>当你的用例需要按照顺序执行就说明你的用例存在依赖，针对这种情况就需要进行拆分，放到不同的组（测试文件）当中来执行，比如说存在a，b，c三个用例，b和c都依赖于a，那么比较合理的做法就是将a提到另外一个文件当中进行测试，b和c放到另外一个文件中，在b和c的文件中将a放入setUp方法用作b、c执行的前提，这样就能比较好的进行测试，也减少了大量的冗余代码。</p><h3 id="multiple-calls-made-to-XCTestExpectation-fulfill"><a href="#multiple-calls-made-to-XCTestExpectation-fulfill" class="headerlink" title="multiple calls made to -[XCTestExpectation fulfill]"></a>multiple calls made to -[XCTestExpectation fulfill]</h3><p>出现这种情况是因为写在回调当中的XCTestExpectation被多次调用导致的，解决这个错误，网上目前有以下三种解决方案，可以根据自己的情况进行选择：</p><p>1.使用__weak修饰XCTestExpectation。</p><p><code>[expectation fulfill]</code>执行一次后方法执行完毕，局部变量expectation被释放，当回调再次调起时，expectation已被释放置nil，执行<code>fulfill</code>不会报错。</p><pre><code>- (void)testExample {    NSString *username = @&quot;shuhai&quot;;    NSString *password = @&quot;123&quot;;    __weak XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);        [expectation fulfill];    }];    [self waitForExpectationsWithTimeout:self.timeout handler:nil];}</code></pre><p>但是该种方法存在一个问题，就是当有多个XCTestExpectation时，靠前的expectation执行<code>fulfill</code>时，该方法并不一定结束，导致再次调用<code>fulfill</code>报错，如下当noticeExpectation所在的回调被第二次调用时，expectation可能并未<code>fulfill</code>，变回导致noticeExpectation多次<code>fulfill</code>报错。</p><pre><code>- (void)testExample {    NSString *username = @&quot;shuhai&quot;;    NSString *password = @&quot;123&quot;;    __weak XCTestExpectation *noticeExpectation = [self expectationWithDescription:@&quot;登录通知返回&quot;];    [SHUserCenter registerNotice:SHUCenterNoticeTypeLoginSuccess handle:^(NSDictionary *data) {    XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);    [noticeExpectation fulfill];}];    __weak XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);        [expectation fulfill];    }];    [self waitForExpectations:@[noticeExpectation,expectation] timeout:self.timeout];}</code></pre><p>2.使用__block修饰XCTestExpectation并在fulfill之后置为nil</p><p>当XCTestExpectation对象执行过<code>fulfill</code>之后被置为了nil，再次调用<code>fulfill</code>则不会报错。</p><pre><code>- (void)testExample {    NSString *username = @&quot;shuhai&quot;;    NSString *password = @&quot;123&quot;;    __block XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);        [expectation fulfill];        expectation = nil;    }];    [self waitForExpectationsWithTimeout:self.timeout handler:nil];}</code></pre><p>这种方法在大部分情况可以可以解决问题，有种特殊的情况我们后面再讨论</p><p>3.移除回调的多次调用逻辑。</p><p>查找并移除回调多次调用的逻辑是从根本上解决这种问题的方法，但是某些业务场景下我们可能是需要回调多次调用的，针对这种情况，我们就可以采用第二种方法来解决问题。</p><h3 id="超时之后fulfill错误无法上报"><a href="#超时之后fulfill错误无法上报" class="headerlink" title="超时之后fulfill错误无法上报"></a>超时之后fulfill错误无法上报</h3><p>这种错误是因为等待XCTestExpectation超时测试方法执行完毕后，回调调用（比如网络不好超时的情况），而且返回了一个错误的结果，在回调当中的断言失败却无法上报错误导致的崩溃，错误信息大致如下：</p><pre><code>Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Unable to report test assertion failure &apos;((data) != nil) failed: throwing &quot;Unable to report test assertion failure &apos;((data) != nil) failed&apos; from /Users/yzq/Documents/Component/CHLUserCenter/Example/Tests/CHLUserCenterNoDataTests.m:31 because it was raised inside test case -[CHLUserCenterNoDataTests test001] which has no associated XCTestRun object. This may happen when test cases are constructed and invoked independently of standard XCTest infrastructure, or when the test has already finished.&quot;&apos; from /Users/yzq/Documents/Component/CHLUserCenter/Example/Tests/CHLUserCenterNoDataTests.m:31 because it was raised inside test case -[CHLUserCenterNoDataTests test001] which has no associated XCTestRun object. This may happen when test cases are constructed and invoked independently of standard XCTest infrastructure, or when the test has already finished.&apos;</code></pre><p>这种错误在上面提到的使用__block的情况下也不能幸免，解决方案就是使用一个__block修饰的变量，将回调当中要获取的值取出来，然后再外层进行数据判断，这样就不会导致断言在回调当中崩溃了。</p><pre><code>- (void)testExample {    NSString *username = @&quot;shuhai&quot;;    NSString *password = @&quot;123&quot;;    __block XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];    __block NSDictionary *returnData = nil;    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {        returnData = data;        [expectation fulfill];        expectation = nil;    }];    [self waitForExpectationsWithTimeout:self.timeout handler:nil];    XCTAssertNotNil([returnData objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);}</code></pre><h3 id="Assertion-failure-in-XCTestExpectation-fulfill"><a href="#Assertion-failure-in-XCTestExpectation-fulfill" class="headerlink" title="Assertion failure in -[XCTestExpectation fulfill]"></a>Assertion failure in -[XCTestExpectation fulfill]</h3><p>这个错误是当有多个XCTestExpectation时使用<code>waitForExpectations:timeout:</code>等待Expectation导致，导致错误的具体原因目前还不是很明确，有了解具体原因的同学可以告诉我下。</p><p>针对这个问题，我们可以使用<code>waitForExpectationsWithTimeout:handler:</code>来等待Expectation，这样就不会报错了。</p><h3 id="attempt-to-insert-nil-object-from-objects-0"><a href="#attempt-to-insert-nil-object-from-objects-0" class="headerlink" title="attempt to insert nil object from objects[0]"></a>attempt to insert nil object from objects[0]</h3><p>这个错误是因为我们在前面使用__block修饰XCTestExpectation并置为nil操作的解决方案时同时使用了<code>waitForExpectations:timeout:</code>来等待Expectation，向数组中插入了nil。</p><p>这个问题的解决方案同上，使用<code>waitForExpectationsWithTimeout:handler:</code>来替换即可。所以针对大多数啊情况推荐使用<code>waitForExpectationsWithTimeout:handler:</code>来等待XCTestExpectation。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编写用例时注意&quot;&gt;&lt;a href=&quot;#编写用例时注意&quot; class=&quot;headerlink&quot; title=&quot;编写用例时注意&quot;&gt;&lt;/a&gt;编写用例时注意&lt;/h3&gt;&lt;p&gt;1.用例只针对SDK对外开放的入口&lt;/p&gt;
&lt;p&gt;2.注意异常情况和边界值&lt;/p&gt;
&lt;p&gt;3.注意用例之间的依赖情况&lt;/p&gt;
&lt;h3 id=&quot;单测用例如何按照顺序执行&quot;&gt;&lt;a href=&quot;#单测用例如何按照顺序执行&quot; class=&quot;headerlink&quot; title=&quot;单测用例如何按照顺序执行&quot;&gt;&lt;/a&gt;单测用例如何按照顺序执行&lt;/h3&gt;&lt;p&gt;测试函数的执行顺序与测试的字符大小有关系，如- (void)test001Example &amp;gt; - (void)test002Example &amp;gt; - (void)testExample&lt;/p&gt;
&lt;p&gt;理论上单元测试不应该控制用例的执行顺序，每个case都能够单独执行，但是针对某些特殊的情况，可以适当使用一次此特性。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS单元测试-代码实现</title>
    <link href="http://yoursite.com/2019/01/09/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/01/09/iOS单元测试-代码实现/</id>
    <published>2019-01-09T08:09:18.000Z</published>
    <updated>2019-01-28T09:06:40.080Z</updated>
    
    <content type="html"><![CDATA[<p>iOS的单元测试代码我们使用Xcode自带的XCTest，XCTest可以从逻辑和性能两个方向进行测试，下面我们来一起看下如何实现。</p><h3 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h3><p>1.为工程添加一个单元测试的Target（已经有的可以略过这一步）<a id="more"></a></p><p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-1.png" alt="20190109-1"></p><p>2.为单元测试Target添加测试文件</p><p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-2.png" alt="20190109-2"></p><p>3.编写测试逻辑</p><pre><code>//每个用例方法执行前会执行的方法，为用例准备环境- (void)setUp {    // Put setup code here. This method is called before the invocation of each test method in the class.}//每个用例方法执行后会执行的方法，对环境进行清洁或者重置- (void)tearDown {    // Put teardown code here. This method is called after the invocation of each test method in the class.}//以test开头的方法是一个可执行的测试用例方法，我们通过这些方法来跑不同的用例- (void)testExample {    // This is an example of a functional test case.    // Use XCTAssert and related functions to verify your tests produce the correct results.    NSInteger i = 1;    NSInteger j = 1;    NSInteger k = i + j;    XCTAssertEqual(k, 2, @&quot;k的值应该等于2&quot;);    //使用XCTAssert断言来判断执行的结果是否通过}</code></pre><p>4.执行单元测试</p><p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-3.png" alt="20190109-3"></p><p>5.查看测试结果</p><p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-4.png" alt="20190109-4"></p><h4 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h4><p>针对异步执行的代码我们需要这样写</p><pre><code>- (void)setUp {    //超时时间，单位为秒    self.timeout = 20;}- (void)tearDown {    // Put teardown code here. This method is called after the invocation of each test method in the class.}- (void)testExample {    NSString *username = @&quot;shuhai&quot;;    NSString *password = @&quot;123&quot;;    XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);        [expectation fulfill];    }];    //waitForExpectationsWithTimeout:handler:方法会阻塞当前测试线程，直到所有的XCTestExpectation fulfill    [self waitForExpectationsWithTimeout:self.timeout handler:nil];}</code></pre><p>另外waitForExpectations:timeout:方法可以等待多个特定的XCTestExpectation</p><pre><code>- (void)setUp {    //超时时间，单位为秒    self.timeout = 20;}- (void)tearDown {    // Put teardown code here. This method is called after the invocation of each test method in the class.}- (void)testExample {    NSString *username = @&quot;shuhai&quot;;    NSString *password = @&quot;123&quot;;    XCTestExpectation *noticeExpectation = [self expectationWithDescription:@&quot;登录通知返回&quot;];    [SHUserCenter registerNotice:SHUCenterNoticeTypeLoginSuccess handle:^(NSDictionary *data) {    XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);    [noticeExpectation fulfill];}];    XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);        [expectation fulfill];    }];    [self waitForExpectations:@[noticeExpectation,expectation] timeout:self.timeout];}</code></pre><p>笔者推荐使用waitForExpectationsWithTimeout:handler:方法。</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>需要了解一段代码执行了多长时间，可以采用如下方法</p><pre><code>- (void)testPerformanceExample {    // This is an example of a performance test case.    [self measureBlock:^{        // Put the code you want to measure the time of here.        sleep(5);    }];}</code></pre><p>这个方法<code>measureBlock</code>在执行时会执行10次，并且在执行完时会告诉你执行10次的时间。第一次执行<code>testPerformanceExample</code>完时会提示你输入一个该方法执行时间的参考值（baseline）作为参考。同时你也可以点击数字查看每次具体执行的结果，如下图：</p><p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-7.png" alt="20190109-7"></p><h3 id="查看单测覆盖率"><a href="#查看单测覆盖率" class="headerlink" title="查看单测覆盖率"></a>查看单测覆盖率</h3><p>首先在Edit scheme-&gt;Test-&gt;Options下勾选Code Coverage</p><p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-5.png" alt="20190109-5"></p><p>然后运行一次单元测试，在report navigator上选择刚刚单测的Coverage选项，就可以看到单元测试覆盖率了</p><p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-6.png" alt="20190109-6"></p><h3 id="常用的XCTAssert断言"><a href="#常用的XCTAssert断言" class="headerlink" title="常用的XCTAssert断言"></a>常用的XCTAssert断言</h3><pre><code>XCTFail(...)    强制失败断言XCTAssertNil(expression, ...)        为nil时通过XCTAssertNotNil(expression, ...)    不为nil时通过XCTAssertTrue(expression, ...)    为true时通过XCTAssertFalse(expression, ...)    为false时通过XCTAssertEqualObjects(expression1, expression2, ...)    两个对象相等时通过XCTAssertNotEqualObjects(expression1, expression2, ...)    两个对象不相等时通过XCTAssertEqual(expression1, expression2, ...)        相等时通过XCTAssertNotEqual(expression1, expression2, ...)    不相等时通过更多的可以查看系统XCTestAssertions.h文件当中的注释</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在编写单元测试时如果遇到问题可以参考<a href="http://yangzq007.com/2019/01/09/iOS单元测试-各种问题/" target="_blank" rel="noopener">iOS单元测试-各种问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS的单元测试代码我们使用Xcode自带的XCTest，XCTest可以从逻辑和性能两个方向进行测试，下面我们来一起看下如何实现。&lt;/p&gt;
&lt;h3 id=&quot;逻辑测试&quot;&gt;&lt;a href=&quot;#逻辑测试&quot; class=&quot;headerlink&quot; title=&quot;逻辑测试&quot;&gt;&lt;/a&gt;逻辑测试&lt;/h3&gt;&lt;p&gt;1.为工程添加一个单元测试的Target（已经有的可以略过这一步）
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>记一次cp错误</title>
    <link href="http://yoursite.com/2018/11/15/%E8%AE%B0%E4%B8%80%E6%AC%A1cp%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/11/15/记一次cp错误/</id>
    <published>2018-11-15T09:19:03.000Z</published>
    <updated>2018-12-29T06:23:37.873Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在编写脚本时遇到一个奇怪错误</p><pre><code>rm -rf /Users/yzq/b/*cp -r /Users/yzq/a/* /Users/yzq/b</code></pre><p>使用这两个命令将a下面的工程拷贝的b中，然后编译b却始终报错，提示某个framework文件重复</p><p>a工程编译是没有问题的<br>手动清空b，将a中的文件手动复制到b编译也没有问题</p><p>最初以为是<code>rm -rf /Users/yzq/b/*</code>命令没有清除掉某些缓存或者隐藏文件之类的，后来验证发现和<code>rm</code>无关</p><p>经过文件比较发现报错的framework与正确的framework下某个文件存在差异，正确的是以链接（快捷方式）的方式存在的，而错误的是一个文件夹，文件夹下还有对应的文件，原来这种错误是我们复制时没有保留对应的文件属性导致的，使用<code>cp -a /Users/yzq/a/* /Users/yzq/b</code>进行复制即可解决，因为<code>-a</code>在复制的同时保留了文件的链接及文件属性</p><p>所以正确的命令应该是</p><pre><code>rm -rf /Users/yzq/b/*cp -a /Users/yzq/a/* /Users/yzq/b    </code></pre><a id="more"></a><h3 id="cp命令的一些参数解释"><a href="#cp命令的一些参数解释" class="headerlink" title="cp命令的一些参数解释"></a>cp命令的一些参数解释</h3><p>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并递归复制目录下的所有内容。其作用等于-dpr参数组合。<br>-d：复制时保留链接（快捷方式）。<br>-f：覆盖已经存在的目标文件而不给出提示。<br>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。<br>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。<br>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。<br>-l：不复制文件，只是生成链接文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在编写脚本时遇到一个奇怪错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rf /Users/yzq/b/*
cp -r /Users/yzq/a/* /Users/yzq/b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这两个命令将a下面的工程拷贝的b中，然后编译b却始终报错，提示某个framework文件重复&lt;/p&gt;
&lt;p&gt;a工程编译是没有问题的&lt;br&gt;手动清空b，将a中的文件手动复制到b编译也没有问题&lt;/p&gt;
&lt;p&gt;最初以为是&lt;code&gt;rm -rf /Users/yzq/b/*&lt;/code&gt;命令没有清除掉某些缓存或者隐藏文件之类的，后来验证发现和&lt;code&gt;rm&lt;/code&gt;无关&lt;/p&gt;
&lt;p&gt;经过文件比较发现报错的framework与正确的framework下某个文件存在差异，正确的是以链接（快捷方式）的方式存在的，而错误的是一个文件夹，文件夹下还有对应的文件，原来这种错误是我们复制时没有保留对应的文件属性导致的，使用&lt;code&gt;cp -a /Users/yzq/a/* /Users/yzq/b&lt;/code&gt;进行复制即可解决，因为&lt;code&gt;-a&lt;/code&gt;在复制的同时保留了文件的链接及文件属性&lt;/p&gt;
&lt;p&gt;所以正确的命令应该是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rf /Users/yzq/b/*
cp -a /Users/yzq/a/* /Users/yzq/b    
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 10 library not found for -lstdc++.6</title>
    <link href="http://yoursite.com/2018/10/10/Xcode10-library-not-found-for--lstdc++.6/"/>
    <id>http://yoursite.com/2018/10/10/Xcode10-library-not-found-for--lstdc++.6/</id>
    <published>2018-10-10T09:31:30.000Z</published>
    <updated>2018-10-10T10:12:47.161Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级了Xcode 10，发现编译的时候报如下错误，在Xcode 9上正常：</p><pre><code>library not found for -lstdc++.6</code></pre><p>这个是因为iOS 12废弃了libstdc++，也删除了相关的库，改为使用libc++替代</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>将缺失的库拷贝到原来对应的目录下，使Xcode能够引用</p><p>将相应的库拷贝到如下四个目录当中，才能保证模拟器和真机都能用，缺少哪个库拷贝哪个就行，不用全部拷贝</p><pre><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib//Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib//Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib//Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/</code></pre><p>文件下载：<a href="https://github.com/yangzq007/Resources/tree/master/libstdc" target="_blank" rel="noopener">libstdc++</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果拷贝进去之后重启Xcode编译还是报这个错误，建议在TARGETS-&gt;Build Phases-&gt;Link Binary With Libraries当中把当前依赖添加进去</p><h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>这种方法虽然可以暂时解决问题，但最好还是升级下相关库，使用新的库和API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近升级了Xcode 10，发现编译的时候报如下错误，在Xcode 9上正常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library not found for -lstdc++.6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个是因为iOS 12废弃了libstdc++，也删除了相关的库，
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>编写一个基于node的CLI</title>
    <link href="http://yoursite.com/2018/09/05/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Enode%E7%9A%84CLI/"/>
    <id>http://yoursite.com/2018/09/05/编写一个基于node的CLI/</id>
    <published>2018-09-05T09:27:31.000Z</published>
    <updated>2018-12-29T06:22:48.249Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为需要给其他同事提供一些方便开发的工具，就写了一个基于node的CLI，下面给大家分享下怎么自己去动手写一个基于node的CLI。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当前端工程安装到全局目录下之后，可以直接通过别名来执行package.json当中bin下面的js文件，我们就是通过编写这个js文件来实现相应命令。</p><pre><code>{  &quot;name&quot;: &quot;testnode-cli&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;CLI测试&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;bin&quot;: {    &quot;testnode&quot;: &quot;./bin/index.js&quot;  },  &quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  },  &quot;repository&quot;: {    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git@github.com:yangzq007/testnode-cli.git&quot;  },  &quot;author&quot;: &quot;yangzq007@126.com&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;dependencies&quot;: {    &quot;commander&quot;: &quot;^2.15.1&quot;  }}</code></pre><a id="more"></a><p>上面所展示的示例当中<code>testnode</code>字段是别名，命令头也是由这里决定的，执行的入口是<code>./bin/</code>下的index.js文件</p><h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p>1.创建一个CLI项目文件夹，并在项目目录当中创建一个如上的package.json文件（可以使用<code>npm init</code>命令来创建）</p><p>2.然后在该文件夹目录下运行<code>npm install</code>命令初始化该工程</p><p>3.添加package.json文件当中bin字段对应的js文件</p><p>4.编写js脚本文件实现命令（文件内容如下所示）</p><p>5.使用命令<code>npm install -g</code>将当前项目安装到全局</p><p>6.愉快测试和使用自己编写的命令</p><p>如下是一个简单的js脚本内容，编写安装完毕后，当你在终端输入<code>testnode</code>时，就会输出对应的log</p><pre><code>#!/usr/bin/env nodefunction show () {  console.log(&quot;testnode-cli is comming!&quot;);}show();</code></pre><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>我们虽然可以在show方法中添加我们的处理逻辑，但是我们的脚本只能执行这样一个命令，怎么给它加上参数执行多条命令呢，比如<code>testnode show</code>、<code>testnode delete</code>、<code>testnode add</code>等来执行不同的操作，那我们需要给它添加参数处理的逻辑</p><p>如下是一个简单的参数处理的逻辑</p><pre><code>#!/usr/bin/env nodevar params = {};process.argv.slice(2).forEach( function (item) {  switch (item) {    case &quot;show&quot;:      config.show = true;      break;    case &quot;delete&quot;:      config.delete = true;      break;    case &quot;add&quot;:      config.add = true;      break;    case &quot;-l&quot;:      config.log = true;      break;  }});function show () {  console.log(&quot;testnode-cli is comming!&quot;);}function delete () {    console.log(&quot;do some delete&quot;);    config.log &amp;&amp; console.log(&quot;delete logging&quot;);}function add () {    console.log(&quot;do some add&quot;);    config.log &amp;&amp; console.log(&quot;add logging&quot;);}config.show &amp;&amp; show();config.delete &amp;&amp; delete();config.add &amp;&amp; add();</code></pre><p>或者我们可以使用commander插件来帮我们处理参数，这样效率会更高，commander在开头的package.json文件当中已经引入,实现大致如下</p><pre><code>#!/usr/bin/env nodefunction show () {  console.log(&quot;testnode-cli is comming!&quot;);}function delete () {    console.log(&quot;do some delete&quot;);}function add (name)) {    console.log(`do some add, name:${name}`);}var program = require(&apos;commander&apos;);program  .version(require(&apos;../package.json&apos;).version);program  .command(&apos;show&apos;)              //命令  .description(&apos;展示相关描述&apos;)    //命令描述  .action(function() {    show();                     //命令动作  }).on(&apos;--help&apos;,function() {    console.log(&apos;展示相关信息&apos;);  //选项  });program  .command(&apos;delete&apos;)  .description(&apos;删除相关文件&apos;)  .action(function() {    delete();  });program  .command(&apos;add [name]&apos;)        //带参数的处理  .description(&apos;添加相关文件&apos;)  .action(function(name) {    add(name);  });  program.parse(process.argv);</code></pre><p>commander更详细的用法介绍参考<a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">https://github.com/tj/commander.js</a></p><h3 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h3><p>上面的操作已经基本实现了一个CLI的结构，我们剩下要做的就是实现命令的具体内容了，我们可以通过一些现有的工具来方便实现我们的操作。</p><pre><code>//我们可以使用execSync来创建一个阻塞node的事件循环的shell客户端来执行我们常用的shell命令const execSync = require(&apos;child_process&apos;).execSync;execSync(&apos;ls&apos;);</code></pre><h3 id="脚手架实现"><a href="#脚手架实现" class="headerlink" title="脚手架实现"></a>脚手架实现</h3><p>我们常用的前端脚手架的实现思路一般是在远端创建一个模板工程，在创建我们自己的工程时将远端的模板工程克隆到本地，然后通过CLI实现对模板工程相应关键信息的修改来转换成对应的开发工程。</p><p>为了方便实现替换，我们可能需要在模板当中对一些关键信息使用特殊样式的字符替换，例如用&amp;{projectName}&amp;来占位项目名称，这样在替换时就方便检索和替换，避免出现误操作。</p><p>相关的文件处理和文字处理可能还需要特殊的工具，这里不再详细描述。</p><h3 id="解释器声明"><a href="#解释器声明" class="headerlink" title="解释器声明"></a>解释器声明</h3><p>你可能注意到脚本文件的头一行有个声明，这个是表示用node来执行这个文件，如果没有这句声明，就会用默认的文本编辑器打开相应的js脚本文件。</p><p>windows</p><pre><code>#! node</code></pre><p>linux/unix/mac</p><pre><code>#!/usr/bin/env node</code></pre><p> #!/usr/bin node和#!/usr/bin/env node的区别</p><p>这个在unix类的操作系统才有意义。#!/usr/bin node是告诉操作系统执行这个脚本的时候，调用/usr/bin下的node解释器，#!/usr/bin/env node这种用法是为了防止操作系统用户没有将node装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为需要给其他同事提供一些方便开发的工具，就写了一个基于node的CLI，下面给大家分享下怎么自己去动手写一个基于node的CLI。&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;当前端工程安装到全局目录下之后，可以直接通过别名来执行package.json当中bin下面的js文件，我们就是通过编写这个js文件来实现相应命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;testnode-cli&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;CLI测试&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;bin&amp;quot;: {
    &amp;quot;testnode&amp;quot;: &amp;quot;./bin/index.js&amp;quot;
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;
  },
  &amp;quot;repository&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;git@github.com:yangzq007/testnode-cli.git&amp;quot;
  },
  &amp;quot;author&amp;quot;: &amp;quot;yangzq007@126.com&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;commander&amp;quot;: &amp;quot;^2.15.1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods target has transitive dependencies that include static frameworks</title>
    <link href="http://yoursite.com/2018/07/09/Cocoapods-transitive-dependencies-that-include-static-frameworks/"/>
    <id>http://yoursite.com/2018/07/09/Cocoapods-transitive-dependencies-that-include-static-frameworks/</id>
    <published>2018-07-09T07:35:17.000Z</published>
    <updated>2018-12-29T03:12:08.538Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个新的Swift工程，在引用旧的objective-c的pod时开启了<code>use_frameworks!</code>配置项，结果在<code>pod install</code>和<code>pod update</code>出现了这么一个问题</p><pre><code>target has transitive dependencies that include static frameworks: (AAA)</code></pre><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>Podfile中不使用use_frameworks!时是会生成相应的.a（静态链接库）文件，然后通过static libraries来管理pod代码，在Linked时会包含该pod引用的其他的pod的.a文件</p><p>Podfile中使用use_frameworks!时是会生成相应的.framework文件（动态链接库：实际内容为Header+动态链接库+资源文件），然后通过dynamic frameworks的方式来管理pod代码，在Linked时会包含该pod引用的其他的pod的.framework文件</p><p>我们开启了use_frameworks!以动态framework的方式引用了AAA，然而AAA实际上是一个静态库，需要拷贝并链接到该pod中，然而dynamic frameworks方式并不会这么做，所以就报错了。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在引用AAA的pod的podspec文件当中开启static_framework配置</p><pre><code>s.static_framework = true</code></pre><p>把该pod作为一个静态framework来编译链接，这样AAA就会被拷贝链接到到该pod的framework当中，这样就能正常引用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在写一个新的Swift工程，在引用旧的objective-c的pod时开启了&lt;code&gt;use_frameworks!&lt;/code&gt;配置项，结果在&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;出现了这么一个问题&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS Archive之后出现Other Items无法导出</title>
    <link href="http://yoursite.com/2018/05/28/iOS-Archive%E4%B9%8B%E5%90%8E%E5%87%BA%E7%8E%B0Other-Items%E6%97%A0%E6%B3%95%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2018/05/28/iOS-Archive之后出现Other-Items无法导出/</id>
    <published>2018-05-28T09:58:30.000Z</published>
    <updated>2018-05-28T10:46:04.086Z</updated>
    
    <content type="html"><![CDATA[<p>最近在iOS打包时碰到了无法导出为ipa的情况，问题表现为打包之后包出现在Other Items下而不是iOS Apps下。</p><p>这是因为打包的项目中某些配置导致打出来的包多了一些文件，网上大致有以下几种解决方案：</p><p>1.依赖工程的skip install设置为Yes，Build Settings-&gt;Deployment-&gt;Skip Install</p><p>2.依赖工程Build Phases-&gt;Copy Headers中所有的头文件拉到Project下，即Public和Private下不能有文件</p><p>3.清空Build Settings-&gt;Deployment-&gt;Installation Directory选项的内容</p><p>这里我需要指出的是如果你是升级了CocoaPods之后出现的这种情况，而且CocoaPods的版本大于1.3.1并且小于1.5.2，那么也有可能是CocoaPods的脚本错误造成的，所以可以尝试下</p><p>4.将CocoaPods降级至1.3.1或者升级为大于等于1.5.2的版本</p><p>另外苹果官方有个文档，虽然比较旧，也可以参考下<br><a href="https://developer.apple.com/library/content/technotes/tn2215/_index.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/technotes/tn2215/_index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在iOS打包时碰到了无法导出为ipa的情况，问题表现为打包之后包出现在Other Items下而不是iOS Apps下。&lt;/p&gt;
&lt;p&gt;这是因为打包的项目中某些配置导致打出来的包多了一些文件，网上大致有以下几种解决方案：&lt;/p&gt;
&lt;p&gt;1.依赖工程的skip insta
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods重复生成UUID的问题</title>
    <link href="http://yoursite.com/2018/05/28/CocoaPods%E9%87%8D%E5%A4%8D%E7%94%9F%E6%88%90UUID%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/28/CocoaPods重复生成UUID的问题/</id>
    <published>2018-05-28T09:39:14.000Z</published>
    <updated>2018-12-29T03:12:13.106Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用CocoaPods在<code>pod install</code>或者<code>pod update</code>时会出现<code>[!] [Xcodeproj] Generated duplicate UUIDs:</code>的错误，大段的warning占满整个终端。</p><p>解决方案：</p><p>终端执行如下命令</p><pre><code>export COCOAPODS_DISABLE_DETERMINISTIC_UUIDS=YES</code></pre><p>后续CocoaPods已经把该配置移入到Podfile当中，执行上面命令无效的可以在Podfile当中添加如下配置即可：</p><pre><code>//建议放在文件开始或者source之后    install! &apos;cocoapods&apos;, :deterministic_uuids =&gt; false</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近使用CocoaPods在&lt;code&gt;pod install&lt;/code&gt;或者&lt;code&gt;pod update&lt;/code&gt;时会出现&lt;code&gt;[!] [Xcodeproj] Generated duplicate UUIDs:&lt;/code&gt;的错误，大段的warning占
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>主题替换为NexT</title>
    <link href="http://yoursite.com/2018/04/04/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2%E4%B8%BANexT/"/>
    <id>http://yoursite.com/2018/04/04/主题替换为NexT/</id>
    <published>2018-04-04T08:28:10.000Z</published>
    <updated>2018-04-08T02:40:59.992Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直觉得博客的主题在显示比较多的文字和代码的时候略显凌乱，而且不太方便阅读，所以就把博客主题替换成了NexT。NexT在文字排版上比较清晰，而且界面元素也不多，可以使自己把更多的关注点放在内容上。</p><p>NexT主题地址：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>1.NexT有4个scheme，每个scheme对应一个不同的布局，可以在<code>_config.yml</code>当中设置</p><pre><code># ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemesscheme: Muse# scheme: Mist#scheme: Pisces</code></pre><p>2.大于5.0.1小于6.0.0版本的NexT在<code>sudo hexo generate</code>时速度会特别慢，不知道是不是个例，在使用的时候注意一下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直觉得博客的主题在显示比较多的文字和代码的时候略显凌乱，而且不太方便阅读，所以就把博客主题替换成了NexT。NexT在文字排版上比较清晰，而且界面元素也不多，可以使自己把更多的关注点放在内容上。&lt;/p&gt;
&lt;p&gt;NexT主题地址：&lt;a href=&quot;https://git
      
    
    </summary>
    
    
      <category term="博客历程" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从ReactNative到React</title>
    <link href="http://yoursite.com/2018/03/29/%E4%BB%8EReactNative%E5%88%B0React/"/>
    <id>http://yoursite.com/2018/03/29/从ReactNative到React/</id>
    <published>2018-03-29T01:44:31.000Z</published>
    <updated>2018-12-29T06:21:57.250Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写自己的一个前端小Demo，因为之前在工作中使用了ReactNative，就选择了React作为技术选型，也就走上了这么一条自上而下的路。本文主要内容为ReactNative和Reactjs的一些不同以及从ReactNative到Reactjs的一些开发中的经验，因此适合从原生转向前端或者对前端有些兴趣的同学，希望能帮大家少踩一些坑，少费一些力。</p><h3 id="安装脚手架和搭建基础工程"><a href="#安装脚手架和搭建基础工程" class="headerlink" title="安装脚手架和搭建基础工程"></a>安装脚手架和搭建基础工程</h3><pre><code>//-g是将create-react-app安装到全局，该电脑的任何用户都可以使用npm install -g create-react-appcreate-react-app my-appcd my-appnpm start</code></pre><p>这样我们就有一个基础的工程和基础的页面了，下面我们就开始讨论详细的问题了<a id="more"></a></p><h3 id="1-自定义字体问题"><a href="#1-自定义字体问题" class="headerlink" title="1.自定义字体问题"></a>1.自定义字体问题</h3><p>自定义字体首先我们需要下载相应的字体并放到工程当中，然后在工程的App.css文件当中添加<code>@font-face</code>，实例如下：</p><pre><code>@font-face{font-family: EBGaramond;                //EBGaramond为自定义名称src: url(&apos;EBGaramond08-Italic.ttf&apos;)}</code></pre><p>然后我们就可以在App.js当中和其他页面文件当中使用<code>fontFamily: &#39;EBGaramond&#39;</code>了</p><p>我们也可以自己新建一个css文件，但是要记得在App.js和页面文件当中导入</p><h3 id="2-文件重复导入问题"><a href="#2-文件重复导入问题" class="headerlink" title="2.文件重复导入问题"></a>2.文件重复导入问题</h3><pre><code>import &apos;./App.css&apos;;import &apos;./Font.css&apos;;</code></pre><p>这种导入整个文件的方式导入后是全局的，顶级文件导入后其他地方就不再需要导入了，与导入类不同，导入类需要在每个使用的页面导入</p><h3 id="3-布局方式问题-1"><a href="#3-布局方式问题-1" class="headerlink" title="3.布局方式问题-1"></a>3.布局方式问题-1</h3><p>ReactNative当中默认使用的是flex布局，flex-direction为column，而在Reactjs当中布局方式为一个从上往下的流式布局（该名词有待商榷，因为暂时不了解一些前端术语，故先这么称呼），这就需要我们修改它的布局方式。我的第一反应是在css添加这样一个样式</p><pre><code>.content {  display: flex;  flex-direction: column}</code></pre><p>但是这种方式需要每个页面都需要写一个content的选择器，后来我就改成了这种方式</p><pre><code>body *:not(style) {  display: flex;  flex-direction: column    //Reactjs当中flex-direction默认为row，需要修改}</code></pre><p>至于为什么是<code>body *:not(style)</code>，那是因为*会把<code>header</code>，<code>body</code>，<code>footer</code>当中的所有内容都会当做html元素，所以我们只需要让body当中的所有内容使用flex布局即可，至于为什么有<code>not(style)</code>，那是因为它还会把body当中的style作为html元素，所以要除开。</p><h3 id="4-布局方式问题-2"><a href="#4-布局方式问题-2" class="headerlink" title="4.布局方式问题-2"></a>4.布局方式问题-2</h3><p>在使用了flex布局之后，你会发现当一行元素填充满的时候，这些元素并不会换行，那是因为在Reactjs当中flexWrap默认为nowrap，需要设置为wrap</p><pre><code>body *:not(style) {      display: flex;      flex-direction: column;    //Reactjs当中flex-direction默认为row，需要修改      flexWrap: wrap}</code></pre><p>在js样式文件中为</p><pre><code>const styles = {    content: {        flexWrap: &apos;wrap&apos;    }};</code></pre><h3 id="其他后续更新中"><a href="#其他后续更新中" class="headerlink" title="其他后续更新中"></a>其他后续更新中</h3><p>……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写自己的一个前端小Demo，因为之前在工作中使用了ReactNative，就选择了React作为技术选型，也就走上了这么一条自上而下的路。本文主要内容为ReactNative和Reactjs的一些不同以及从ReactNative到Reactjs的一些开发中的经验，因此适合从原生转向前端或者对前端有些兴趣的同学，希望能帮大家少踩一些坑，少费一些力。&lt;/p&gt;
&lt;h3 id=&quot;安装脚手架和搭建基础工程&quot;&gt;&lt;a href=&quot;#安装脚手架和搭建基础工程&quot; class=&quot;headerlink&quot; title=&quot;安装脚手架和搭建基础工程&quot;&gt;&lt;/a&gt;安装脚手架和搭建基础工程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//-g是将create-react-app安装到全局，该电脑的任何用户都可以使用
npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们就有一个基础的工程和基础的页面了，下面我们就开始讨论详细的问题了
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2017年个人总结</title>
    <link href="http://yoursite.com/2018/01/09/2017%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/09/2017年个人总结/</id>
    <published>2018-01-09T10:06:59.000Z</published>
    <updated>2019-01-28T08:20:35.753Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20180109-1.jpg" alt="20180109-1"></p><a id="more"></a><p>最近手头事情终于不是那么多了，也可以静下来做个2017年的总结了，给自己打个tag，也希望自己新的一年能够继续努力。</p><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>工作内容大致有以下几点：</p><ul><li>日常Native </li><li>ReactNative及前端相关</li><li>工程结构调整和优化</li><li>脚本工具</li></ul><p>一些计划：</p><ul><li>逆向</li></ul><p>今年工作没有太大的变动，整体比较稳定，在这过去的一年中，感觉自己收获还是蛮大的。</p><h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>好的方面：</p><p>作息比以前规律了<br>自己开始做饭了</p><p>坏的方面：</p><p>打羽毛球的习惯冬天中断了</p><p>希望天气稍微转暖之后可以恢复打球活动，另外再加强一下其他锻炼，毕竟身体是革命的本钱。同时也希望自己多去其他地方走走，收获一些不同的体验和感受。</p><h3 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h3><ul><li>《人类简史》</li></ul><p>今年的人文阅读似乎有点少，希望18年可以稍微改进下，但是也不打算强迫自己，这种东西随性就好，毕竟记忆和感受才是重点。</p><h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>转眼博客已经走过了两年，希望自己能再接再厉，把这个好习惯坚持下去，也希望将来有一天它能见证自己这一路走来的足迹。</p><h3 id="其他感慨"><a href="#其他感慨" class="headerlink" title="其他感慨"></a>其他感慨</h3><p>今年过的好快……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20180109-1.jpg&quot; alt=&quot;20180109-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>MobX绑定过程和其中的一些坑的总结</title>
    <link href="http://yoursite.com/2017/10/19/MobX%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B%E5%92%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/19/MobX绑定过程和其中的一些坑的总结/</id>
    <published>2017-10-19T07:03:15.000Z</published>
    <updated>2018-12-29T03:11:38.892Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20171019-1.png" alt="20171019-1"></p><a id="more"></a><p>开发过程中使用Mobx极大的方便了我们，但是在使用过程中还是会或多或少地遇到一些问题导致绑定失败，下面我们来一起探讨下Mobx的绑定过程，以方便我们来更好的使用它。</p><blockquote><p>MobX 会对在追踪函数执行过程中读取现存的可观察属性做出反应。</p></blockquote><p>MobX的官方文档将MobX的绑定及相应过程总结为这么一句话，并标出了“读取”、“追踪函数”和“过程”三个关键字。</p><h3 id="Mobx会收集哪些地方的绑定"><a href="#Mobx会收集哪些地方的绑定" class="headerlink" title="Mobx会收集哪些地方的绑定"></a>Mobx会收集哪些地方的绑定</h3><blockquote><p>“追踪函数” 是 <code>computed</code> 表达式、<code>observer</code> 组件的 <code>render()</code> 方法和 <code>when</code>、<code>reaction</code> 和 <code>autorun</code> 的第一个入参函数。</p></blockquote><p>文档说明的也比较清楚，会对文件当中的<code>@computed</code>修饰的方法、<code>render()</code>方法、<code>when</code>方法的第一个入参函数、<code>reaction</code>方法的第一个入参函数、<code>autorun</code>方法的第一个入参函数这些地方收集，MobX会在页面加载执行前扫描所有的文件，收集这些地方的绑定。</p><p>以下调用和赋值<code>this.store.listA</code>的地方，MobX都会去收集绑定，其它的地方则不会去收集。</p><pre><code>//数据绑定文件import { computed, observable } from &apos;mobx&apos;;class IndexStore {    @observable listA = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];    @observable listB = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];    @computed get dataA() {        return this.listA;    }}//Index视图文件import { observer } from &apos;mobx-react/native&apos;;import IndexStore from &apos;indexStore&apos;;@observerclass Index extends Component {    constructor() {        super();        this.store = new IndexStore();        when(            () =&gt; this.store.listA.length == 0,            () =&gt; console.log(&quot;listA none&quot;)        );    }    const autorun1 = autorun(() =&gt; {        console.log(this.store.listA);    })    const reaction2 = reaction(        () =&gt; this.store.listA,        listA =&gt; console.log(listA.join(&quot;, &quot;))    )    render() {        return (            &lt;MainItem dataSource={this.store.listA}            renderHeader={                () =&gt; &lt;Item data={this.store.listB}&gt;&lt;/Item&gt;            } /&gt;        )    }}</code></pre><h3 id="MobX会收集哪些绑定"><a href="#MobX会收集哪些绑定" class="headerlink" title="MobX会收集哪些绑定"></a>MobX会收集哪些绑定</h3><blockquote><p>“过程(during)” 意味着只追踪那些在函数执行时被读取的 <code>observable</code> 。这些值是否由追踪函数直接或间接使用并不重要。</p></blockquote><p>这句话解释了MobX收集哪些绑定，是那些在函数执行时被读取的<code>observable</code>，例如上面实例代码<code>&lt;MainItem dataSource={this.store.listA}/&gt;</code>中的<code>this.store.listA</code>，它在<code>render()</code>函数执行时被调用，用于作为<code>MainItem</code>的数据源，所以这个绑定就被收集到了，<code>render()</code>函数和<code>listA</code>之间就建立了联系，当<code>listA</code>发生变化时，<code>render()</code>函数就会被调用，界面也就从新渲染刷新了。同理，上面的一些log也会调用，会在控制台输出相应信息。</p><p>需要注意的是上面实例代码中的<code>renderHeader={() =&gt; &lt;Item data={this.store.listB}&gt;&lt;/Item&gt;}</code>当中的<code>this.store.listB</code>并不会被收集到，为什么呢？因为<code>renderHeader</code>作为一个属性传入<code>MainItem</code>，<code>renderHeader</code>当中的<code>this.store.listB</code>并没有在<code>Index</code>的<code>render()</code>去使用，而是在<code>Item</code>当中使用了它，所以<code>Index</code>的<code>render()</code>并没有与<code>listB</code>之间建立连接，当<code>listB</code>发生变化就不会调用<code>Index</code>的<code>render()</code>，界面也就不会重新渲染刷新。</p><p>我们想在修改<code>listB</code>时让界面刷新作出相应，我们该怎么办呢？我们需要在<code>Item</code>当中添加<code>@observer</code>去捕获这个绑定，因为<code>listB</code>在<code>Item</code>的<code>render()</code>当中进行了调用，所以正确的写法如下：</p><pre><code>//Index视图文件render() {    return (        &lt;MainItem dataSource={this.store.listA}             renderHeader={                   () =&gt; &lt;Item data={this.store}&gt;&lt;/Item&gt;         } /&gt;    )}//Item视图文件import { observer } from &apos;mobx-react/native&apos;;@observerclass Item extends Component {    constructor() {        super();    }    render() {        return (            &lt;Text&gt;{this.props.data.listB[0]}&lt;/Text&gt;        )    }}</code></pre><p>Tips：当我们修改<code>listB</code>时，<code>Item</code>就会重新调用其<code>render()</code>函数重新渲染，我们重新渲染<code>Item</code>比重新渲染整个<code>Index</code>所消耗的资源会更少，虽然MobX已经有机制帮我们减少不必要的渲染，但是这样还是会消耗更少的资源，所以官方推荐我们绑定粒度越细越好。</p><p>细心的同学可能会注意到为什么<code>Item</code>的<code>data</code>当中是<code>this.store</code>而不是我们认为的<code>this.store.listB</code>，是写错了吗，并不是，这恰恰是正确的写法，下面我们就来讨论下这个问题。</p><h3 id="MobX绑定了什么"><a href="#MobX绑定了什么" class="headerlink" title="MobX绑定了什么"></a>MobX绑定了什么</h3><blockquote><p>“读取” 是对象属性的间接引用，可以用过 <code>.</code> (例如 <code>user.name</code>) 或者 <code>[]</code> (例如 <code>user[&#39;name&#39;]</code>) 的形式完成。</p></blockquote><p>这句话解释了MobX绑定了什么，它绑定的是可观察对象的引用，例如上面提到的<code>listA</code>，MobX并不是将<code>listA</code>的内容<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code>与<code>render()</code>函数绑定，而是将<code>listA</code>变量对<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code>的引用与<code>render()</code>函数绑定绑定，所以只有当<code>listA</code>对值的引用发生变化时，<code>render()</code>函数才会调用。（也可以理解为c/c++当中的指针的概念，<code>render()</code>函数是与<code>listA</code>变量的指针值绑定）</p><p>所以针对上面的<code>listA</code>，你只修改数组的内容，render()函数是不会调用的，界面也是不会刷新的。下面这种写法，界面并不会刷新：</p><pre><code>//数据绑定文件modifyListA1() {    this.listA[0] = &quot;4&quot;;}//此处只是数组[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]的内容发生了变化，listA的引用却没有发生变化</code></pre><p>正确的写法</p><pre><code>//数据绑定文件modifyListA2() {    this.listA = [&quot;4&quot;,&quot;2&quot;,&quot;3&quot;];}//此处listA被赋值了一个新数组[&quot;4&quot;,&quot;2&quot;,&quot;3&quot;]，listA的引用发生了变化</code></pre><p>我们再回到<code>listB</code>的问题上，如果我们是<code>&lt;Item data={this.store.listB}&gt;&lt;/Item&gt;</code>这种写法，我们相当于把<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>这个值传递给了<code>Item</code>当中的<code>data</code>，通过<code>data</code>对数组的操作，并未出现<code>listB</code>的引用，也就无法建立绑定。而我们将整个<code>store</code>传递过去，<code>data</code>就被赋值了<code>store</code>的内容，当<code>data</code>引用<code>listB</code>时，也就出现了<code>listB</code>的引用，这样绑定才建立了起来。</p><p>所以针对子组件，需要将被观察属性的父级传递过去，这样才能在子组件中出现被观察属性的引用，才能建立绑定。</p><h3 id="MobX绑定过程"><a href="#MobX绑定过程" class="headerlink" title="MobX绑定过程"></a>MobX绑定过程</h3><p>了解了以上三个概念，MobX的绑定过程就比较清晰了。MobX在代码编译时/代码执行之前扫描代码中的<code>computed</code> 表达式、<code>observer</code> 组件的 <code>render()</code> 方法等地方，将这些方法中出现的直接调用的观察属性的引用和这些方法绑定起来，这就是MobX的绑定过程。绑定完成之后，当这些引用发生变化时，相应的绑定方法就调用，界面就会刷新重新渲染或者相应的逻辑就会执行。</p><h3 id="observable和-observable"><a href="#observable和-observable" class="headerlink" title="observable和@observable"></a>observable和@observable</h3><p>上面我们<code>modifyListA1</code>提到的修改并不会触发绑定的界面刷新操作，需要我们使用<code>modifyListA2</code>当中的修改方式，给<code>listA</code>提供一个新数组，改变它的引用值。那有没有方法可以让<code>listA</code>只修改一个值（如<code>modifyListA1</code>当中的操作）就触发界面的刷新呢，答案是肯定的，我们只需要将<code>listA</code>初始的赋值方式改成如下方式即可：</p><pre><code>//数据绑定文件import { computed, observable } from &apos;mobx&apos;;class IndexStore {    listA = observable([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]);    @observable listB = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];    @computed get dataA() {        return this.listA;    }}</code></pre><p>为什么这种方式就可以呢？因为<code>observable</code>默认情况下会递归应用，相比较<code>@observable</code>细粒度的观察，只监测<code>listA</code>的引用，<code>observable</code>则会递归这些观察，将<code>listA[0]</code>、<code>listA[1]</code>、<code>listA[2]</code>的引用都作为监测对象，这样<code>listA[0]</code>、<code>listA[1]</code>、<code>listA[2]</code>的引用就和<code>render()</code>函数建立起了绑定，当<code>listA[0]</code>被赋值，引用发生变化时，<code>render()</code>也就被调用了，界面也就刷新了。</p><p>如果需要一个数据源的内部数据发生变化引起相应操作，我们可以使用<code>observable</code>，然而<code>observable</code>也有它的弊端，它会建立起来比较多的冗余绑定，也会使后续的维护变得复杂，总体上我们推荐使用<code>@observable</code>这样细粒度的控制，它会使我们的项目更加清晰便于维护，同时也会大大的降低那些莫名其妙的bug的概率。</p><h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><p>详情参考官方文档</p><p><a href="http://cn.mobx.js.org/best/react.html" target="_blank" rel="noopener">MobX 会对什么作出反应?</a></p><p><a href="http://cn.mobx.js.org/best/pitfalls.html" target="_blank" rel="noopener">常见陷阱与最佳实践</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20171019-1.png&quot; alt=&quot;20171019-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
