<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>那片树海</title>
  <subtitle>用心做一件工艺品</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-18T08:28:11.811Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>树海</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS单元测试-各种问题</title>
    <link href="http://yoursite.com/2019/01/09/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/09/iOS单元测试-各种问题/</id>
    <published>2019-01-09T08:09:57.000Z</published>
    <updated>2019-01-18T08:28:11.811Z</updated>
    
    <content type="html"><![CDATA[<h3 id="编写用例时注意"><a href="#编写用例时注意" class="headerlink" title="编写用例时注意"></a>编写用例时注意</h3><p>1.用例只针对SDK对外开放的入口</p>
<p>2.注意异常情况和边界值</p>
<p>3.注意用例之间的依赖情况</p>
<h3 id="单测用例如何按照顺序执行"><a href="#单测用例如何按照顺序执行" class="headerlink" title="单测用例如何按照顺序执行"></a>单测用例如何按照顺序执行</h3><p>测试函数的执行顺序与测试的字符大小有关系，如- (void)test001Example &gt; - (void)test002Example &gt; - (void)testExample</p>
<p>理论上单元测试不应该控制用例的执行顺序，每个case都能够单独执行，但是针对某些特殊的情况，可以适当使用一次此特性。</p>
<h3 id="用例依赖的情况如何处理"><a href="#用例依赖的情况如何处理" class="headerlink" title="用例依赖的情况如何处理"></a>用例依赖的情况如何处理</h3><p>当你的用例需要按照顺序执行就说明你的用例存在依赖，针对这种情况就需要进行拆分，放到不同的组（测试文件）当中来执行，比如说存在a，b，c三个用例，b和c都依赖于a，那么比较合理的做法就是将a提到另外一个文件当中进行测试，b和c放到另外一个文件中，在b和c的文件中将a放入setUp方法用作b、c执行的前提，这样就能比较好的进行测试，也减少了大量的冗余代码。</p>
<h3 id="multiple-calls-made-to-XCTestExpectation-fulfill"><a href="#multiple-calls-made-to-XCTestExpectation-fulfill" class="headerlink" title="multiple calls made to -[XCTestExpectation fulfill]"></a>multiple calls made to -[XCTestExpectation fulfill]</h3><p>出现这种情况是因为写在回调当中的XCTestExpectation被多次调用导致的，解决这个错误，网上目前有以下三种解决方案，可以根据自己的情况进行选择：</p>
<p>1.使用__weak修饰XCTestExpectation。</p>
<p><code>[expectation fulfill]</code>执行一次后方法执行完毕，局部变量expectation被释放，当回调再次调起时，expectation已被释放置nil，执行<code>fulfill</code>不会报错。</p>
<pre><code>- (void)testExample {
    NSString *username = @&quot;shuhai&quot;;
    NSString *password = @&quot;123&quot;;

    __weak XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];

    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {
        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
        [expectation fulfill];
    }];
    [self waitForExpectationsWithTimeout:self.timeout handler:nil];
}
</code></pre><p>但是该种方法存在一个问题，就是当有多个XCTestExpectation时，靠前的expectation执行<code>fulfill</code>时，该方法并不一定结束，导致再次调用<code>fulfill</code>报错，如下当noticeExpectation所在的回调被第二次调用时，expectation可能并未<code>fulfill</code>，变回导致noticeExpectation多次<code>fulfill</code>报错。</p>
<pre><code>- (void)testExample {
    NSString *username = @&quot;shuhai&quot;;
    NSString *password = @&quot;123&quot;;

    __weak XCTestExpectation *noticeExpectation = [self expectationWithDescription:@&quot;登录通知返回&quot;];
    [SHUserCenter registerNotice:SHUCenterNoticeTypeLoginSuccess handle:^(NSDictionary *data) {
    XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
    [noticeExpectation fulfill];
}];

    __weak XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];
    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {
        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
        [expectation fulfill];
    }];
    [self waitForExpectations:@[noticeExpectation,expectation] timeout:self.timeout];
}
</code></pre><p>2.使用__block修饰XCTestExpectation并在fulfill之后置为nil</p>
<p>当XCTestExpectation对象执行过<code>fulfill</code>之后被置为了nil，再次调用<code>fulfill</code>则不会报错。</p>
<pre><code>- (void)testExample {
    NSString *username = @&quot;shuhai&quot;;
    NSString *password = @&quot;123&quot;;

    __block XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];

    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {
        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
        [expectation fulfill];
        expectation = nil;
    }];
    [self waitForExpectationsWithTimeout:self.timeout handler:nil];
}
</code></pre><p>这种方法在大部分情况可以可以解决问题，有种特殊的情况我们后面再讨论</p>
<p>3.移除回调的多次调用逻辑。</p>
<p>查找并移除回调多次调用的逻辑是从根本上解决这种问题的方法，但是某些业务场景下我们可能是需要回调多次调用的，针对这种情况，我们就可以采用第二种方法来解决问题。</p>
<h3 id="超时之后fulfill错误无法上报"><a href="#超时之后fulfill错误无法上报" class="headerlink" title="超时之后fulfill错误无法上报"></a>超时之后fulfill错误无法上报</h3><p>这种错误是因为等待XCTestExpectation超时测试方法执行完毕后，回调调用（比如网络不好超时的情况），而且返回了一个错误的结果，在回调当中的断言失败却无法上报错误导致的崩溃，错误信息大致如下：</p>
<pre><code>Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, 
reason: &apos;Unable to report test assertion failure &apos;((data) != nil) 
failed: throwing &quot;Unable to report test assertion failure &apos;((data) != nil) failed&apos; from /Users/yzq/Documents/Component/CHLUserCenter/Example/Tests/CHLUserCenterNoDataTests.m:31 because it was raised inside test case -[CHLUserCenterNoDataTests test001] which has no associated XCTestRun object. 
This may happen when test cases are constructed and invoked independently of standard XCTest infrastructure, or when the test has already finished.&quot;
&apos; from /Users/yzq/Documents/Component/CHLUserCenter/Example/Tests/CHLUserCenterNoDataTests.m:31 because it was raised inside test case -[CHLUserCenterNoDataTests test001] which has no associated XCTestRun object. 
This may happen when test cases are constructed and invoked independently of standard XCTest infrastructure, or when the test has already finished.&apos;
</code></pre><p>这种错误在上面提到的使用__block的情况下也不能幸免，解决方案就是使用一个__block修饰的变量，将回调当中要获取的值取出来，然后再外层进行数据判断，这样就不会导致断言在回调当中崩溃了。</p>
<pre><code>- (void)testExample {
    NSString *username = @&quot;shuhai&quot;;
    NSString *password = @&quot;123&quot;;

    __block XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];
    __block NSDictionary *returnData = nil;

    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {
        returnData = data;
        [expectation fulfill];
        expectation = nil;
    }];
    [self waitForExpectationsWithTimeout:self.timeout handler:nil];
    XCTAssertNotNil([returnData objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
}
</code></pre><h3 id="Assertion-failure-in-XCTestExpectation-fulfill"><a href="#Assertion-failure-in-XCTestExpectation-fulfill" class="headerlink" title="Assertion failure in -[XCTestExpectation fulfill]"></a>Assertion failure in -[XCTestExpectation fulfill]</h3><p>这个错误是当有多个XCTestExpectation时使用<code>waitForExpectations:timeout:</code>等待Expectation导致，导致错误的具体原因目前还不是很明确，有了解具体原因的同学可以告诉我下。</p>
<p>针对这个问题，我们可以使用<code>waitForExpectationsWithTimeout:handler:</code>来等待Expectation，这样就不会报错了。</p>
<h3 id="attempt-to-insert-nil-object-from-objects-0"><a href="#attempt-to-insert-nil-object-from-objects-0" class="headerlink" title="attempt to insert nil object from objects[0]"></a>attempt to insert nil object from objects[0]</h3><p>这个错误是因为我们在前面使用__block修饰XCTestExpectation并置为nil操作的解决方案时同时使用了<code>waitForExpectations:timeout:</code>来等待Expectation，向数组中插入了nil。</p>
<p>这个问题的解决方案同上，使用<code>waitForExpectationsWithTimeout:handler:</code>来替换即可。所以针对大多数啊情况推荐使用<code>waitForExpectationsWithTimeout:handler:</code>来等待XCTestExpectation。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;编写用例时注意&quot;&gt;&lt;a href=&quot;#编写用例时注意&quot; class=&quot;headerlink&quot; title=&quot;编写用例时注意&quot;&gt;&lt;/a&gt;编写用例时注意&lt;/h3&gt;&lt;p&gt;1.用例只针对SDK对外开放的入口&lt;/p&gt;
&lt;p&gt;2.注意异常情况和边界值&lt;/p&gt;
&lt;p&gt;3.注意用
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS单元测试-代码实现</title>
    <link href="http://yoursite.com/2019/01/09/iOS%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/01/09/iOS单元测试-代码实现/</id>
    <published>2019-01-09T08:09:18.000Z</published>
    <updated>2019-01-18T02:35:21.731Z</updated>
    
    <content type="html"><![CDATA[<p>iOS的单元测试代码我们使用Xcode自带的XCTest，XCTest可以从逻辑和性能两个方向进行测试，下面我们来一起看下如何实现。</p>
<h3 id="逻辑测试"><a href="#逻辑测试" class="headerlink" title="逻辑测试"></a>逻辑测试</h3><p>1.为工程添加一个单元测试的Target（已经有的可以略过这一步）</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-1.png" alt="20190109-1"></p>
<p>2.为单元测试Target添加测试文件</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-2.png" alt="20190109-2"></p>
<p>3.编写测试逻辑</p>
<pre><code>//每个用例方法执行前会执行的方法，为用例准备环境
- (void)setUp {
    // Put setup code here. This method is called before the invocation of each test method in the class.
}

//每个用例方法执行后会执行的方法，对环境进行清洁或者重置
- (void)tearDown {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
}

//以test开头的方法是一个可执行的测试用例方法，我们通过这些方法来跑不同的用例
- (void)testExample {
    // This is an example of a functional test case.
    // Use XCTAssert and related functions to verify your tests produce the correct results.
    NSInteger i = 1;
    NSInteger j = 1;
    NSInteger k = i + j;
    XCTAssertEqual(k, 2, @&quot;k的值应该等于2&quot;);
    //使用XCTAssert断言来判断执行的结果是否通过
}
</code></pre><p>4.执行单元测试</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-3.png" alt="20190109-3"></p>
<p>5.查看测试结果</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-4.png" alt="20190109-4"></p>
<h4 id="异步测试"><a href="#异步测试" class="headerlink" title="异步测试"></a>异步测试</h4><p>针对异步执行的代码我们需要这样写</p>
<pre><code>- (void)setUp {
    //超时时间，单位为秒
    self.timeout = 20;
}

- (void)tearDown {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
}

- (void)testExample {
    NSString *username = @&quot;shuhai&quot;;
    NSString *password = @&quot;123&quot;;

    XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];

    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {
        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
        [expectation fulfill];
    }];
    //waitForExpectationsWithTimeout:handler:方法会阻塞当前测试线程，直到所有的XCTestExpectation fulfill
    [self waitForExpectationsWithTimeout:self.timeout handler:nil];
}
</code></pre><p>另外waitForExpectations:timeout:方法可以等待多个特定的XCTestExpectation</p>
<pre><code>- (void)setUp {
    //超时时间，单位为秒
    self.timeout = 20;
}

- (void)tearDown {
    // Put teardown code here. This method is called after the invocation of each test method in the class.
}

- (void)testExample {
    NSString *username = @&quot;shuhai&quot;;
    NSString *password = @&quot;123&quot;;

    XCTestExpectation *noticeExpectation = [self expectationWithDescription:@&quot;登录通知返回&quot;];
    [SHUserCenter registerNotice:SHUCenterNoticeTypeLoginSuccess handle:^(NSDictionary *data) {
    XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
    [noticeExpectation fulfill];
}];

    XCTestExpectation *expectation = [self expectationWithDescription:@&quot;登录请求返回&quot;];
    [SHUserCenter loginWithUserName: username password: password callback:^(NSDictionary *data) {
        XCTAssertNotNil([data objectForKey:@&quot;data&quot;],@&quot;返回结果不能为nil&quot;);
        [expectation fulfill];
    }];
    [self waitForExpectations:@[noticeExpectation,expectation] timeout:self.timeout];
}
</code></pre><p>笔者推荐使用waitForExpectationsWithTimeout:handler:方法。</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>需要了解一段代码执行了多长时间，可以采用如下方法</p>
<pre><code>- (void)testPerformanceExample {
    // This is an example of a performance test case.
    [self measureBlock:^{
        // Put the code you want to measure the time of here.
        sleep(5);
    }];
}
</code></pre><p>这个方法<code>measureBlock</code>在执行时会执行10次，并且在执行完时会告诉你执行10次的时间。第一次执行<code>testPerformanceExample</code>完时会提示你输入一个该方法执行时间的参考值（baseline）作为参考。同时你也可以点击数字查看每次具体执行的结果，如下图：</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-7.png" alt="20190109-7"></p>
<h3 id="查看单测覆盖率"><a href="#查看单测覆盖率" class="headerlink" title="查看单测覆盖率"></a>查看单测覆盖率</h3><p>首先在Edit scheme-&gt;Test-&gt;Options下勾选Code Coverage</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-5.png" alt="20190109-5"></p>
<p>然后运行一次单元测试，在report navigator上选择刚刚单测的Coverage选项，就可以看到单元测试覆盖率了</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20190109-6.png" alt="20190109-6"></p>
<h3 id="常用的XCTAssert断言"><a href="#常用的XCTAssert断言" class="headerlink" title="常用的XCTAssert断言"></a>常用的XCTAssert断言</h3><pre><code>XCTFail(...)    强制失败断言
XCTAssertNil(expression, ...)        为nil时通过
XCTAssertNotNil(expression, ...)    不为nil时通过
XCTAssertTrue(expression, ...)    为true时通过
XCTAssertFalse(expression, ...)    为false时通过
XCTAssertEqualObjects(expression1, expression2, ...)    两个对象相等时通过
XCTAssertNotEqualObjects(expression1, expression2, ...)    两个对象不相等时通过
XCTAssertEqual(expression1, expression2, ...)        相等时通过
XCTAssertNotEqual(expression1, expression2, ...)    不相等时通过

更多的可以查看系统XCTestAssertions.h文件当中的注释
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS的单元测试代码我们使用Xcode自带的XCTest，XCTest可以从逻辑和性能两个方向进行测试，下面我们来一起看下如何实现。&lt;/p&gt;
&lt;h3 id=&quot;逻辑测试&quot;&gt;&lt;a href=&quot;#逻辑测试&quot; class=&quot;headerlink&quot; title=&quot;逻辑测试&quot;&gt;&lt;/a&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>记一次cp错误</title>
    <link href="http://yoursite.com/2018/11/15/%E8%AE%B0%E4%B8%80%E6%AC%A1cp%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/11/15/记一次cp错误/</id>
    <published>2018-11-15T09:19:03.000Z</published>
    <updated>2018-12-29T06:23:37.872Z</updated>
    
    <content type="html"><![CDATA[<p>前两天在编写脚本时遇到一个奇怪错误</p>
<pre><code>rm -rf /Users/yzq/b/*
cp -r /Users/yzq/a/* /Users/yzq/b
</code></pre><p>使用这两个命令将a下面的工程拷贝的b中，然后编译b却始终报错，提示某个framework文件重复</p>
<p>a工程编译是没有问题的<br>手动清空b，将a中的文件手动复制到b编译也没有问题</p>
<p>最初以为是<code>rm -rf /Users/yzq/b/*</code>命令没有清除掉某些缓存或者隐藏文件之类的，后来验证发现和<code>rm</code>无关</p>
<p>经过文件比较发现报错的framework与正确的framework下某个文件存在差异，正确的是以链接（快捷方式）的方式存在的，而错误的是一个文件夹，文件夹下还有对应的文件，原来这种错误是我们复制时没有保留对应的文件属性导致的，使用<code>cp -a /Users/yzq/a/* /Users/yzq/b</code>进行复制即可解决，因为<code>-a</code>在复制的同时保留了文件的链接及文件属性</p>
<p>所以正确的命令应该是</p>
<pre><code>rm -rf /Users/yzq/b/*
cp -a /Users/yzq/a/* /Users/yzq/b    
</code></pre><a id="more"></a>
<h3 id="cp命令的一些参数解释"><a href="#cp命令的一些参数解释" class="headerlink" title="cp命令的一些参数解释"></a>cp命令的一些参数解释</h3><p>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并递归复制目录下的所有内容。其作用等于-dpr参数组合。<br>-d：复制时保留链接（快捷方式）。<br>-f：覆盖已经存在的目标文件而不给出提示。<br>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。<br>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。<br>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。<br>-l：不复制文件，只是生成链接文件。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前两天在编写脚本时遇到一个奇怪错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rf /Users/yzq/b/*
cp -r /Users/yzq/a/* /Users/yzq/b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用这两个命令将a下面的工程拷贝的b中，然后编译b却始终报错，提示某个framework文件重复&lt;/p&gt;
&lt;p&gt;a工程编译是没有问题的&lt;br&gt;手动清空b，将a中的文件手动复制到b编译也没有问题&lt;/p&gt;
&lt;p&gt;最初以为是&lt;code&gt;rm -rf /Users/yzq/b/*&lt;/code&gt;命令没有清除掉某些缓存或者隐藏文件之类的，后来验证发现和&lt;code&gt;rm&lt;/code&gt;无关&lt;/p&gt;
&lt;p&gt;经过文件比较发现报错的framework与正确的framework下某个文件存在差异，正确的是以链接（快捷方式）的方式存在的，而错误的是一个文件夹，文件夹下还有对应的文件，原来这种错误是我们复制时没有保留对应的文件属性导致的，使用&lt;code&gt;cp -a /Users/yzq/a/* /Users/yzq/b&lt;/code&gt;进行复制即可解决，因为&lt;code&gt;-a&lt;/code&gt;在复制的同时保留了文件的链接及文件属性&lt;/p&gt;
&lt;p&gt;所以正确的命令应该是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rm -rf /Users/yzq/b/*
cp -a /Users/yzq/a/* /Users/yzq/b    
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Shell" scheme="http://yoursite.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Xcode 10 library not found for -lstdc++.6</title>
    <link href="http://yoursite.com/2018/10/10/Xcode10-library-not-found-for--lstdc++.6/"/>
    <id>http://yoursite.com/2018/10/10/Xcode10-library-not-found-for--lstdc++.6/</id>
    <published>2018-10-10T09:31:30.000Z</published>
    <updated>2018-10-10T10:12:47.160Z</updated>
    
    <content type="html"><![CDATA[<p>最近升级了Xcode 10，发现编译的时候报如下错误，在Xcode 9上正常：</p>
<pre><code>library not found for -lstdc++.6
</code></pre><p>这个是因为iOS 12废弃了libstdc++，也删除了相关的库，改为使用libc++替代</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>将缺失的库拷贝到原来对应的目录下，使Xcode能够引用</p>
<p>将相应的库拷贝到如下四个目录当中，才能保证模拟器和真机都能用，缺少哪个库拷贝哪个就行，不用全部拷贝</p>
<pre><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/
/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/
/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/
</code></pre><p>文件下载：<a href="https://github.com/yangzq007/Resources/tree/master/libstdc" target="_blank" rel="external">libstdc++</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果拷贝进去之后重启Xcode编译还是报这个错误，建议在TARGETS-&gt;Build Phases-&gt;Link Binary With Libraries当中把当前依赖添加进去</p>
<h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>这种方法虽然可以暂时解决问题，但最好还是升级下相关库，使用新的库和API。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近升级了Xcode 10，发现编译的时候报如下错误，在Xcode 9上正常：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;library not found for -lstdc++.6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个是因为iOS 12废弃了libstdc++，也删除了相关的库，
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>编写一个基于node的CLI</title>
    <link href="http://yoursite.com/2018/09/05/%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Enode%E7%9A%84CLI/"/>
    <id>http://yoursite.com/2018/09/05/编写一个基于node的CLI/</id>
    <published>2018-09-05T09:27:31.000Z</published>
    <updated>2018-12-29T06:22:48.249Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为需要给其他同事提供一些方便开发的工具，就写了一个基于node的CLI，下面给大家分享下怎么自己去动手写一个基于node的CLI。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当前端工程安装到全局目录下之后，可以直接通过别名来执行package.json当中bin下面的js文件，我们就是通过编写这个js文件来实现相应命令。</p>
<pre><code>{
  &quot;name&quot;: &quot;testnode-cli&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;CLI测试&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;bin&quot;: {
    &quot;testnode&quot;: &quot;./bin/index.js&quot;
  },
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;repository&quot;: {
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;git@github.com:yangzq007/testnode-cli.git&quot;
  },
  &quot;author&quot;: &quot;yangzq007@126.com&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;commander&quot;: &quot;^2.15.1&quot;
  }
}
</code></pre><a id="more"></a>
<p>上面所展示的示例当中<code>testnode</code>字段是别名，命令头也是由这里决定的，执行的入口是<code>./bin/</code>下的index.js文件</p>
<h3 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h3><p>1.创建一个CLI项目文件夹，并在项目目录当中创建一个如上的package.json文件（可以使用<code>npm init</code>命令来创建）</p>
<p>2.然后在该文件夹目录下运行<code>npm install</code>命令初始化该工程</p>
<p>3.添加package.json文件当中bin字段对应的js文件</p>
<p>4.编写js脚本文件实现命令（文件内容如下所示）</p>
<p>5.使用命令<code>npm install -g</code>将当前项目安装到全局</p>
<p>6.愉快测试和使用自己编写的命令</p>
<p>如下是一个简单的js脚本内容，编写安装完毕后，当你在终端输入<code>testnode</code>时，就会输出对应的log</p>
<pre><code>#!/usr/bin/env node

function show () {
  console.log(&quot;testnode-cli is comming!&quot;);
}

show();
</code></pre><h3 id="添加参数"><a href="#添加参数" class="headerlink" title="添加参数"></a>添加参数</h3><p>我们虽然可以在show方法中添加我们的处理逻辑，但是我们的脚本只能执行这样一个命令，怎么给它加上参数执行多条命令呢，比如<code>testnode show</code>、<code>testnode delete</code>、<code>testnode add</code>等来执行不同的操作，那我们需要给它添加参数处理的逻辑</p>
<p>如下是一个简单的参数处理的逻辑</p>
<pre><code>#!/usr/bin/env node

var params = {};
process.argv.slice(2).forEach( function (item) {
  switch (item) {
    case &quot;show&quot;:
      config.show = true;
      break;
    case &quot;delete&quot;:
      config.delete = true;
      break;
    case &quot;add&quot;:
      config.add = true;
      break;
    case &quot;-l&quot;:
      config.log = true;
      break;
  }
});

function show () {
  console.log(&quot;testnode-cli is comming!&quot;);
}

function delete () {
    console.log(&quot;do some delete&quot;);
    config.log &amp;&amp; console.log(&quot;delete logging&quot;);
}

function add () {
    console.log(&quot;do some add&quot;);
    config.log &amp;&amp; console.log(&quot;add logging&quot;);
}

config.show &amp;&amp; show();
config.delete &amp;&amp; delete();
config.add &amp;&amp; add();
</code></pre><p>或者我们可以使用commander插件来帮我们处理参数，这样效率会更高，commander在开头的package.json文件当中已经引入,实现大致如下</p>
<pre><code>#!/usr/bin/env node

function show () {
  console.log(&quot;testnode-cli is comming!&quot;);
}

function delete () {
    console.log(&quot;do some delete&quot;);
}

function add (name)) {
    console.log(`do some add, name:${name}`);
}

var program = require(&apos;commander&apos;);

program
  .version(require(&apos;../package.json&apos;).version);

program
  .command(&apos;show&apos;)              //命令
  .description(&apos;展示相关描述&apos;)    //命令描述
  .action(function() {
    show();                     //命令动作
  }).on(&apos;--help&apos;,function() {
    console.log(&apos;展示相关信息&apos;);  //选项
  });

program
  .command(&apos;delete&apos;)
  .description(&apos;删除相关文件&apos;)
  .action(function() {
    delete();
  });

program
  .command(&apos;add [name]&apos;)        //带参数的处理
  .description(&apos;添加相关文件&apos;)
  .action(function(name) {
    add(name);
  });

  program.parse(process.argv);
</code></pre><p>commander更详细的用法介绍参考<a href="https://github.com/tj/commander.js" target="_blank" rel="external">https://github.com/tj/commander.js</a></p>
<h3 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h3><p>上面的操作已经基本实现了一个CLI的结构，我们剩下要做的就是实现命令的具体内容了，我们可以通过一些现有的工具来方便实现我们的操作。</p>
<pre><code>//我们可以使用execSync来创建一个阻塞node的事件循环的shell客户端来执行我们常用的shell命令
const execSync = require(&apos;child_process&apos;).execSync;
execSync(&apos;ls&apos;);
</code></pre><h3 id="脚手架实现"><a href="#脚手架实现" class="headerlink" title="脚手架实现"></a>脚手架实现</h3><p>我们常用的前端脚手架的实现思路一般是在远端创建一个模板工程，在创建我们自己的工程时将远端的模板工程克隆到本地，然后通过CLI实现对模板工程相应关键信息的修改来转换成对应的开发工程。</p>
<p>为了方便实现替换，我们可能需要在模板当中对一些关键信息使用特殊样式的字符替换，例如用&amp;{projectName}&amp;来占位项目名称，这样在替换时就方便检索和替换，避免出现误操作。</p>
<p>相关的文件处理和文字处理可能还需要特殊的工具，这里不再详细描述。</p>
<h3 id="解释器声明"><a href="#解释器声明" class="headerlink" title="解释器声明"></a>解释器声明</h3><p>你可能注意到脚本文件的头一行有个声明，这个是表示用node来执行这个文件，如果没有这句声明，就会用默认的文本编辑器打开相应的js脚本文件。</p>
<p>windows</p>
<pre><code>#! node
</code></pre><p>linux/unix/mac</p>
<pre><code>#!/usr/bin/env node
</code></pre><p> #!/usr/bin node和#!/usr/bin/env node的区别</p>
<p>这个在unix类的操作系统才有意义。#!/usr/bin node是告诉操作系统执行这个脚本的时候，调用/usr/bin下的node解释器，#!/usr/bin/env node这种用法是为了防止操作系统用户没有将node装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近因为需要给其他同事提供一些方便开发的工具，就写了一个基于node的CLI，下面给大家分享下怎么自己去动手写一个基于node的CLI。&lt;/p&gt;
&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;当前端工程安装到全局目录下之后，可以直接通过别名来执行package.json当中bin下面的js文件，我们就是通过编写这个js文件来实现相应命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;testnode-cli&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;CLI测试&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;bin&amp;quot;: {
    &amp;quot;testnode&amp;quot;: &amp;quot;./bin/index.js&amp;quot;
  },
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp;&amp;amp; exit 1&amp;quot;
  },
  &amp;quot;repository&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;git&amp;quot;,
    &amp;quot;url&amp;quot;: &amp;quot;git@github.com:yangzq007/testnode-cli.git&amp;quot;
  },
  &amp;quot;author&amp;quot;: &amp;quot;yangzq007@126.com&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;ISC&amp;quot;,
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;commander&amp;quot;: &amp;quot;^2.15.1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods target has transitive dependencies that include static frameworks</title>
    <link href="http://yoursite.com/2018/07/09/Cocoapods-transitive-dependencies-that-include-static-frameworks/"/>
    <id>http://yoursite.com/2018/07/09/Cocoapods-transitive-dependencies-that-include-static-frameworks/</id>
    <published>2018-07-09T07:35:17.000Z</published>
    <updated>2018-12-29T03:12:08.537Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写一个新的Swift工程，在引用旧的objective-c的pod时开启了<code>use_frameworks!</code>配置项，结果在<code>pod install</code>和<code>pod update</code>出现了这么一个问题</p>
<pre><code>target has transitive dependencies that include static frameworks: (AAA)
</code></pre><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>Podfile中不使用use_frameworks!时是会生成相应的.a（静态链接库）文件，然后通过static libraries来管理pod代码，在Linked时会包含该pod引用的其他的pod的.a文件</p>
<p>Podfile中使用use_frameworks!时是会生成相应的.framework文件（动态链接库：实际内容为Header+动态链接库+资源文件），然后通过dynamic frameworks的方式来管理pod代码，在Linked时会包含该pod引用的其他的pod的.framework文件</p>
<p>我们开启了use_frameworks!以动态framework的方式引用了AAA，然而AAA实际上是一个静态库，需要拷贝并链接到该pod中，然而dynamic frameworks方式并不会这么做，所以就报错了。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在引用AAA的pod的podspec文件当中开启static_framework配置</p>
<pre><code>s.static_framework = true
</code></pre><p>把该pod作为一个静态framework来编译链接，这样AAA就会被拷贝链接到到该pod的framework当中，这样就能正常引用了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个新的Swift工程，在引用旧的objective-c的pod时开启了&lt;code&gt;use_frameworks!&lt;/code&gt;配置项，结果在&lt;code&gt;pod install&lt;/code&gt;和&lt;code&gt;pod update&lt;/code&gt;出现了这么一个问题&lt;/p&gt;

    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>iOS Archive之后出现Other Items无法导出</title>
    <link href="http://yoursite.com/2018/05/28/iOS-Archive%E4%B9%8B%E5%90%8E%E5%87%BA%E7%8E%B0Other-Items%E6%97%A0%E6%B3%95%E5%AF%BC%E5%87%BA/"/>
    <id>http://yoursite.com/2018/05/28/iOS-Archive之后出现Other-Items无法导出/</id>
    <published>2018-05-28T09:58:30.000Z</published>
    <updated>2018-05-28T10:46:04.085Z</updated>
    
    <content type="html"><![CDATA[<p>最近在iOS打包时碰到了无法导出为ipa的情况，问题表现为打包之后包出现在Other Items下而不是iOS Apps下。</p>
<p>这是因为打包的项目中某些配置导致打出来的包多了一些文件，网上大致有以下几种解决方案：</p>
<p>1.依赖工程的skip install设置为Yes，Build Settings-&gt;Deployment-&gt;Skip Install</p>
<p>2.依赖工程Build Phases-&gt;Copy Headers中所有的头文件拉到Project下，即Public和Private下不能有文件</p>
<p>3.清空Build Settings-&gt;Deployment-&gt;Installation Directory选项的内容</p>
<p>这里我需要指出的是如果你是升级了CocoaPods之后出现的这种情况，而且CocoaPods的版本大于1.3.1并且小于1.5.2，那么也有可能是CocoaPods的脚本错误造成的，所以可以尝试下</p>
<p>4.将CocoaPods降级至1.3.1或者升级为大于等于1.5.2的版本</p>
<p>另外苹果官方有个文档，虽然比较旧，也可以参考下<br><a href="https://developer.apple.com/library/content/technotes/tn2215/_index.html" target="_blank" rel="external">https://developer.apple.com/library/content/technotes/tn2215/_index.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在iOS打包时碰到了无法导出为ipa的情况，问题表现为打包之后包出现在Other Items下而不是iOS Apps下。&lt;/p&gt;
&lt;p&gt;这是因为打包的项目中某些配置导致打出来的包多了一些文件，网上大致有以下几种解决方案：&lt;/p&gt;
&lt;p&gt;1.依赖工程的skip insta
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods重复生成UUID的问题</title>
    <link href="http://yoursite.com/2018/05/28/CocoaPods%E9%87%8D%E5%A4%8D%E7%94%9F%E6%88%90UUID%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/05/28/CocoaPods重复生成UUID的问题/</id>
    <published>2018-05-28T09:39:14.000Z</published>
    <updated>2018-12-29T03:12:13.105Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用CocoaPods在<code>pod install</code>或者<code>pod update</code>时会出现<code>[!] [Xcodeproj] Generated duplicate UUIDs:</code>的错误，大段的warning占满整个终端。</p>
<p>解决方案：</p>
<p>终端执行如下命令</p>
<pre><code>export COCOAPODS_DISABLE_DETERMINISTIC_UUIDS=YES
</code></pre><p>后续CocoaPods已经把该配置移入到Podfile当中，执行上面命令无效的可以在Podfile当中添加如下配置即可：</p>
<pre><code>//建议放在文件开始或者source之后    
install! &apos;cocoapods&apos;, :deterministic_uuids =&gt; false
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用CocoaPods在&lt;code&gt;pod install&lt;/code&gt;或者&lt;code&gt;pod update&lt;/code&gt;时会出现&lt;code&gt;[!] [Xcodeproj] Generated duplicate UUIDs:&lt;/code&gt;的错误，大段的warning占
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="CocoaPods" scheme="http://yoursite.com/tags/CocoaPods/"/>
    
  </entry>
  
  <entry>
    <title>主题替换为NexT</title>
    <link href="http://yoursite.com/2018/04/04/%E4%B8%BB%E9%A2%98%E6%9B%BF%E6%8D%A2%E4%B8%BANexT/"/>
    <id>http://yoursite.com/2018/04/04/主题替换为NexT/</id>
    <published>2018-04-04T08:28:10.000Z</published>
    <updated>2018-04-08T02:40:59.991Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直觉得博客的主题在显示比较多的文字和代码的时候略显凌乱，而且不太方便阅读，所以就把博客主题替换成了NexT。NexT在文字排版上比较清晰，而且界面元素也不多，可以使自己把更多的关注点放在内容上。</p>
<p>NexT主题地址：<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a></p>
<h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>1.NexT有4个scheme，每个scheme对应一个不同的布局，可以在<code>_config.yml</code>当中设置</p>
<pre><code># ---------------------------------------------------------------
# Scheme Settings
# ---------------------------------------------------------------

# Schemes
scheme: Muse
# scheme: Mist
#scheme: Pisces
</code></pre><p>2.大于5.0.1小于6.0.0版本的NexT在<code>sudo hexo generate</code>时速度会特别慢，不知道是不是个例，在使用的时候注意一下</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直觉得博客的主题在显示比较多的文字和代码的时候略显凌乱，而且不太方便阅读，所以就把博客主题替换成了NexT。NexT在文字排版上比较清晰，而且界面元素也不多，可以使自己把更多的关注点放在内容上。&lt;/p&gt;
&lt;p&gt;NexT主题地址：&lt;a href=&quot;https://git
    
    </summary>
    
    
      <category term="博客历程" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E5%8E%86%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从ReactNative到React</title>
    <link href="http://yoursite.com/2018/03/29/%E4%BB%8EReactNative%E5%88%B0React/"/>
    <id>http://yoursite.com/2018/03/29/从ReactNative到React/</id>
    <published>2018-03-29T01:44:31.000Z</published>
    <updated>2018-12-29T06:21:57.250Z</updated>
    
    <content type="html"><![CDATA[<p>最近在写自己的一个前端小Demo，因为之前在工作中使用了ReactNative，就选择了React作为技术选型，也就走上了这么一条自上而下的路。本文主要内容为ReactNative和Reactjs的一些不同以及从ReactNative到Reactjs的一些开发中的经验，因此适合从原生转向前端或者对前端有些兴趣的同学，希望能帮大家少踩一些坑，少费一些力。</p>
<h3 id="安装脚手架和搭建基础工程"><a href="#安装脚手架和搭建基础工程" class="headerlink" title="安装脚手架和搭建基础工程"></a>安装脚手架和搭建基础工程</h3><pre><code>//-g是将create-react-app安装到全局，该电脑的任何用户都可以使用
npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
</code></pre><p>这样我们就有一个基础的工程和基础的页面了，下面我们就开始讨论详细的问题了<a id="more"></a></p>
<h3 id="1-自定义字体问题"><a href="#1-自定义字体问题" class="headerlink" title="1.自定义字体问题"></a>1.自定义字体问题</h3><p>自定义字体首先我们需要下载相应的字体并放到工程当中，然后在工程的App.css文件当中添加<code>@font-face</code>，实例如下：</p>
<pre><code>@font-face
{
font-family: EBGaramond;                //EBGaramond为自定义名称
src: url(&apos;EBGaramond08-Italic.ttf&apos;)
}
</code></pre><p>然后我们就可以在App.js当中和其他页面文件当中使用<code>fontFamily: &#39;EBGaramond&#39;</code>了</p>
<p>我们也可以自己新建一个css文件，但是要记得在App.js和页面文件当中导入</p>
<h3 id="2-文件重复导入问题"><a href="#2-文件重复导入问题" class="headerlink" title="2.文件重复导入问题"></a>2.文件重复导入问题</h3><pre><code>import &apos;./App.css&apos;;
import &apos;./Font.css&apos;;
</code></pre><p>这种导入整个文件的方式导入后是全局的，顶级文件导入后其他地方就不再需要导入了，与导入类不同，导入类需要在每个使用的页面导入</p>
<h3 id="3-布局方式问题-1"><a href="#3-布局方式问题-1" class="headerlink" title="3.布局方式问题-1"></a>3.布局方式问题-1</h3><p>ReactNative当中默认使用的是flex布局，flex-direction为column，而在Reactjs当中布局方式为一个从上往下的流式布局（该名词有待商榷，因为暂时不了解一些前端术语，故先这么称呼），这就需要我们修改它的布局方式。我的第一反应是在css添加这样一个样式</p>
<pre><code>.content {
  display: flex;
  flex-direction: column
}
</code></pre><p>但是这种方式需要每个页面都需要写一个content的选择器，后来我就改成了这种方式</p>
<pre><code>body *:not(style) {
  display: flex;
  flex-direction: column    //Reactjs当中flex-direction默认为row，需要修改
}
</code></pre><p>至于为什么是<code>body *:not(style)</code>，那是因为*会把<code>header</code>，<code>body</code>，<code>footer</code>当中的所有内容都会当做html元素，所以我们只需要让body当中的所有内容使用flex布局即可，至于为什么有<code>not(style)</code>，那是因为它还会把body当中的style作为html元素，所以要除开。</p>
<h3 id="4-布局方式问题-2"><a href="#4-布局方式问题-2" class="headerlink" title="4.布局方式问题-2"></a>4.布局方式问题-2</h3><p>在使用了flex布局之后，你会发现当一行元素填充满的时候，这些元素并不会换行，那是因为在Reactjs当中flexWrap默认为nowrap，需要设置为wrap</p>
<pre><code>body *:not(style) {
      display: flex;
      flex-direction: column;    //Reactjs当中flex-direction默认为row，需要修改
      flexWrap: wrap
}
</code></pre><p>在js样式文件中为</p>
<pre><code>const styles = {
    content: {
        flexWrap: &apos;wrap&apos;
    }
};
</code></pre><h3 id="其他后续更新中"><a href="#其他后续更新中" class="headerlink" title="其他后续更新中"></a>其他后续更新中</h3><p>……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在写自己的一个前端小Demo，因为之前在工作中使用了ReactNative，就选择了React作为技术选型，也就走上了这么一条自上而下的路。本文主要内容为ReactNative和Reactjs的一些不同以及从ReactNative到Reactjs的一些开发中的经验，因此适合从原生转向前端或者对前端有些兴趣的同学，希望能帮大家少踩一些坑，少费一些力。&lt;/p&gt;
&lt;h3 id=&quot;安装脚手架和搭建基础工程&quot;&gt;&lt;a href=&quot;#安装脚手架和搭建基础工程&quot; class=&quot;headerlink&quot; title=&quot;安装脚手架和搭建基础工程&quot;&gt;&lt;/a&gt;安装脚手架和搭建基础工程&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//-g是将create-react-app安装到全局，该电脑的任何用户都可以使用
npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们就有一个基础的工程和基础的页面了，下面我们就开始讨论详细的问题了
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2017年个人总结</title>
    <link href="http://yoursite.com/2018/01/09/2017%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/09/2017年个人总结/</id>
    <published>2018-01-09T10:06:59.000Z</published>
    <updated>2018-12-29T03:27:05.496Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20180109-1.jpg" alt="20180109-1"></p>
<a id="more"></a>
<p>最近手头事情终于不是那么多了，也可以静下来做个2017年的总结了，给自己打个tag，也希望自己新的一年能够继续努力。</p>
<h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>工作内容大致有以下几点：</p>
<ul>
<li>日常Native </li>
<li>ReactNative及前端相关</li>
<li>工程结构调整和优化</li>
<li>脚本工具</li>
</ul>
<p>一些计划：</p>
<ul>
<li>逆向</li>
</ul>
<p>今年工作没有太大的变动，整体比较稳定，在这过去的一年中，感觉自己收获还是蛮大的。</p>
<h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><p>好的方面：</p>
<p>作息比以前规律了<br>自己开始做饭了</p>
<p>坏的方面：</p>
<p>打羽毛球的习惯冬天中断了</p>
<p>希望天气稍微转暖之后可以恢复打球活动，另外再加强一下其他锻炼，毕竟身体是革命的本钱。同时也希望自己多去其他地方走走，收获一些不同的体验和感受。</p>
<h3 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h3><ul>
<li>《人类简史》</li>
</ul>
<p>今年的人文阅读似乎有点少，希望18年可以稍微改进下，但是也不打算强迫自己，这种东西随性就好，毕竟记忆和感受才是重点。</p>
<h3 id="关于博客"><a href="#关于博客" class="headerlink" title="关于博客"></a>关于博客</h3><p>转眼博客已经走过了两年，希望自己能再接再厉，把这个好习惯坚持下去，也希望将来有一天它能见证自己这一路走来的足迹。</p>
<h3 id="其他感慨"><a href="#其他感慨" class="headerlink" title="其他感慨"></a>其他感慨</h3><p>今年过的好快……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20180109-1.jpg&quot; alt=&quot;20180109-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>MobX绑定过程和其中的一些坑的总结</title>
    <link href="http://yoursite.com/2017/10/19/MobX%E7%BB%91%E5%AE%9A%E8%BF%87%E7%A8%8B%E5%92%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/10/19/MobX绑定过程和其中的一些坑的总结/</id>
    <published>2017-10-19T07:03:15.000Z</published>
    <updated>2018-12-29T03:11:38.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20171019-1.png" alt="20171019-1"></p>
<a id="more"></a>
<p>开发过程中使用Mobx极大的方便了我们，但是在使用过程中还是会或多或少地遇到一些问题导致绑定失败，下面我们来一起探讨下Mobx的绑定过程，以方便我们来更好的使用它。</p>
<blockquote>
<p>MobX 会对在追踪函数执行过程中读取现存的可观察属性做出反应。</p>
</blockquote>
<p>MobX的官方文档将MobX的绑定及相应过程总结为这么一句话，并标出了“读取”、“追踪函数”和“过程”三个关键字。</p>
<h3 id="Mobx会收集哪些地方的绑定"><a href="#Mobx会收集哪些地方的绑定" class="headerlink" title="Mobx会收集哪些地方的绑定"></a>Mobx会收集哪些地方的绑定</h3><blockquote>
<p>“追踪函数” 是 <code>computed</code> 表达式、<code>observer</code> 组件的 <code>render()</code> 方法和 <code>when</code>、<code>reaction</code> 和 <code>autorun</code> 的第一个入参函数。</p>
</blockquote>
<p>文档说明的也比较清楚，会对文件当中的<code>@computed</code>修饰的方法、<code>render()</code>方法、<code>when</code>方法的第一个入参函数、<code>reaction</code>方法的第一个入参函数、<code>autorun</code>方法的第一个入参函数这些地方收集，MobX会在页面加载执行前扫描所有的文件，收集这些地方的绑定。</p>
<p>以下调用和赋值<code>this.store.listA</code>的地方，MobX都会去收集绑定，其它的地方则不会去收集。</p>
<pre><code>//数据绑定文件
import { computed, observable } from &apos;mobx&apos;;

class IndexStore {
    @observable listA = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;];
    @observable listB = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];

    @computed get dataA() {
        return this.listA;
    }
}

//Index视图文件
import { observer } from &apos;mobx-react/native&apos;;
import IndexStore from &apos;indexStore&apos;;

@observer
class Index extends Component {
    constructor() {
        super();
        this.store = new IndexStore();
        when(
            () =&gt; this.store.listA.length == 0,
            () =&gt; console.log(&quot;listA none&quot;)
        );
    }

    const autorun1 = autorun(() =&gt; {
        console.log(this.store.listA);
    })

    const reaction2 = reaction(
        () =&gt; this.store.listA,
        listA =&gt; console.log(listA.join(&quot;, &quot;))
    )

    render() {
        return (
            &lt;MainItem dataSource={this.store.listA}
            renderHeader={
                () =&gt; &lt;Item data={this.store.listB}&gt;&lt;/Item&gt;
            } /&gt;
        )
    }
}
</code></pre><h3 id="MobX会收集哪些绑定"><a href="#MobX会收集哪些绑定" class="headerlink" title="MobX会收集哪些绑定"></a>MobX会收集哪些绑定</h3><blockquote>
<p>“过程(during)” 意味着只追踪那些在函数执行时被读取的 <code>observable</code> 。这些值是否由追踪函数直接或间接使用并不重要。</p>
</blockquote>
<p>这句话解释了MobX收集哪些绑定，是那些在函数执行时被读取的<code>observable</code>，例如上面实例代码<code>&lt;MainItem dataSource={this.store.listA}/&gt;</code>中的<code>this.store.listA</code>，它在<code>render()</code>函数执行时被调用，用于作为<code>MainItem</code>的数据源，所以这个绑定就被收集到了，<code>render()</code>函数和<code>listA</code>之间就建立了联系，当<code>listA</code>发生变化时，<code>render()</code>函数就会被调用，界面也就从新渲染刷新了。同理，上面的一些log也会调用，会在控制台输出相应信息。</p>
<p>需要注意的是上面实例代码中的<code>renderHeader={() =&gt; &lt;Item data={this.store.listB}&gt;&lt;/Item&gt;}</code>当中的<code>this.store.listB</code>并不会被收集到，为什么呢？因为<code>renderHeader</code>作为一个属性传入<code>MainItem</code>，<code>renderHeader</code>当中的<code>this.store.listB</code>并没有在<code>Index</code>的<code>render()</code>去使用，而是在<code>Item</code>当中使用了它，所以<code>Index</code>的<code>render()</code>并没有与<code>listB</code>之间建立连接，当<code>listB</code>发生变化就不会调用<code>Index</code>的<code>render()</code>，界面也就不会重新渲染刷新。</p>
<p>我们想在修改<code>listB</code>时让界面刷新作出相应，我们该怎么办呢？我们需要在<code>Item</code>当中添加<code>@observer</code>去捕获这个绑定，因为<code>listB</code>在<code>Item</code>的<code>render()</code>当中进行了调用，所以正确的写法如下：</p>
<pre><code>//Index视图文件
render() {
    return (
        &lt;MainItem dataSource={this.store.listA}
             renderHeader={
                   () =&gt; &lt;Item data={this.store}&gt;&lt;/Item&gt;
         } /&gt;
    )
}

//Item视图文件
import { observer } from &apos;mobx-react/native&apos;;

@observer
class Item extends Component {
    constructor() {
        super();
    }

    render() {
        return (
            &lt;Text&gt;{this.props.data.listB[0]}&lt;/Text&gt;
        )
    }
}
</code></pre><p>Tips：当我们修改<code>listB</code>时，<code>Item</code>就会重新调用其<code>render()</code>函数重新渲染，我们重新渲染<code>Item</code>比重新渲染整个<code>Index</code>所消耗的资源会更少，虽然MobX已经有机制帮我们减少不必要的渲染，但是这样还是会消耗更少的资源，所以官方推荐我们绑定粒度越细越好。</p>
<p>细心的同学可能会注意到为什么<code>Item</code>的<code>data</code>当中是<code>this.store</code>而不是我们认为的<code>this.store.listB</code>，是写错了吗，并不是，这恰恰是正确的写法，下面我们就来讨论下这个问题。</p>
<h3 id="MobX绑定了什么"><a href="#MobX绑定了什么" class="headerlink" title="MobX绑定了什么"></a>MobX绑定了什么</h3><blockquote>
<p>“读取” 是对象属性的间接引用，可以用过 <code>.</code> (例如 <code>user.name</code>) 或者 <code>[]</code> (例如 <code>user[&#39;name&#39;]</code>) 的形式完成。</p>
</blockquote>
<p>这句话解释了MobX绑定了什么，它绑定的是可观察对象的引用，例如上面提到的<code>listA</code>，MobX并不是将<code>listA</code>的内容<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code>与<code>render()</code>函数绑定，而是将<code>listA</code>变量对<code>[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]</code>的引用与<code>render()</code>函数绑定绑定，所以只有当<code>listA</code>对值的引用发生变化时，<code>render()</code>函数才会调用。（也可以理解为c/c++当中的指针的概念，<code>render()</code>函数是与<code>listA</code>变量的指针值绑定）</p>
<p>所以针对上面的<code>listA</code>，你只修改数组的内容，render()函数是不会调用的，界面也是不会刷新的。下面这种写法，界面并不会刷新：</p>
<pre><code>//数据绑定文件
modifyListA1() {
    this.listA[0] = &quot;4&quot;;
}

//此处只是数组[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]的内容发生了变化，listA的引用却没有发生变化
</code></pre><p>正确的写法</p>
<pre><code>//数据绑定文件
modifyListA2() {
    this.listA = [&quot;4&quot;,&quot;2&quot;,&quot;3&quot;];
}

//此处listA被赋值了一个新数组[&quot;4&quot;,&quot;2&quot;,&quot;3&quot;]，listA的引用发生了变化
</code></pre><p>我们再回到<code>listB</code>的问题上，如果我们是<code>&lt;Item data={this.store.listB}&gt;&lt;/Item&gt;</code>这种写法，我们相当于把<code>[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code>这个值传递给了<code>Item</code>当中的<code>data</code>，通过<code>data</code>对数组的操作，并未出现<code>listB</code>的引用，也就无法建立绑定。而我们将整个<code>store</code>传递过去，<code>data</code>就被赋值了<code>store</code>的内容，当<code>data</code>引用<code>listB</code>时，也就出现了<code>listB</code>的引用，这样绑定才建立了起来。</p>
<p>所以针对子组件，需要将被观察属性的父级传递过去，这样才能在子组件中出现被观察属性的引用，才能建立绑定。</p>
<h3 id="MobX绑定过程"><a href="#MobX绑定过程" class="headerlink" title="MobX绑定过程"></a>MobX绑定过程</h3><p>了解了以上三个概念，MobX的绑定过程就比较清晰了。MobX在代码编译时/代码执行之前扫描代码中的<code>computed</code> 表达式、<code>observer</code> 组件的 <code>render()</code> 方法等地方，将这些方法中出现的直接调用的观察属性的引用和这些方法绑定起来，这就是MobX的绑定过程。绑定完成之后，当这些引用发生变化时，相应的绑定方法就调用，界面就会刷新重新渲染或者相应的逻辑就会执行。</p>
<h3 id="observable和-observable"><a href="#observable和-observable" class="headerlink" title="observable和@observable"></a>observable和@observable</h3><p>上面我们<code>modifyListA1</code>提到的修改并不会触发绑定的界面刷新操作，需要我们使用<code>modifyListA2</code>当中的修改方式，给<code>listA</code>提供一个新数组，改变它的引用值。那有没有方法可以让<code>listA</code>只修改一个值（如<code>modifyListA1</code>当中的操作）就触发界面的刷新呢，答案是肯定的，我们只需要将<code>listA</code>初始的赋值方式改成如下方式即可：</p>
<pre><code>//数据绑定文件
import { computed, observable } from &apos;mobx&apos;;

class IndexStore {
    listA = observable([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]);
    @observable listB = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];

    @computed get dataA() {
        return this.listA;
    }
}
</code></pre><p>为什么这种方式就可以呢？因为<code>observable</code>默认情况下会递归应用，相比较<code>@observable</code>细粒度的观察，只监测<code>listA</code>的引用，<code>observable</code>则会递归这些观察，将<code>listA[0]</code>、<code>listA[1]</code>、<code>listA[2]</code>的引用都作为监测对象，这样<code>listA[0]</code>、<code>listA[1]</code>、<code>listA[2]</code>的引用就和<code>render()</code>函数建立起了绑定，当<code>listA[0]</code>被赋值，引用发生变化时，<code>render()</code>也就被调用了，界面也就刷新了。</p>
<p>如果需要一个数据源的内部数据发生变化引起相应操作，我们可以使用<code>observable</code>，然而<code>observable</code>也有它的弊端，它会建立起来比较多的冗余绑定，也会使后续的维护变得复杂，总体上我们推荐使用<code>@observable</code>这样细粒度的控制，它会使我们的项目更加清晰便于维护，同时也会大大的降低那些莫名其妙的bug的概率。</p>
<h3 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h3><p>详情参考官方文档</p>
<p><a href="http://cn.mobx.js.org/best/react.html" target="_blank" rel="external">MobX 会对什么作出反应?</a></p>
<p><a href="http://cn.mobx.js.org/best/pitfalls.html" target="_blank" rel="external">常见陷阱与最佳实践</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20171019-1.png&quot; alt=&quot;20171019-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Xcode9的一些问题</title>
    <link href="http://yoursite.com/2017/10/10/Xcode9%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/10/10/Xcode9的一些问题/</id>
    <published>2017-10-10T09:55:37.000Z</published>
    <updated>2018-12-29T03:11:38.892Z</updated>
    
    <content type="html"><![CDATA[<p>Xcode9的正式版也使用了一段时间了，bug还是有点多的，总感觉好像是赶工出来的版本，刚开始用的时候还是有点痛苦的，下面就把这些点列出来，大家可以参考一下。</p>
<h3 id="BUG"><a href="#BUG" class="headerlink" title="BUG"></a>BUG</h3><p>1.APP图标不见了</p>
<p>用Xcode9跑起来工程之后发现应用图标不见了，这个是因为CocoaPods的资源脚本有点问题，在Xcode9上资源位置异常，工程引用不到，解决方案是在Podfile添加如下hook代码</p>
<pre><code>post_install do |installer|
    copy_pods_resources_path = &quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&quot;
    string_to_replace = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;&apos;
    assets_compile_with_app_icon_arguments = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot; --app-icon &quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&quot; --output-partial-info-plist &quot;${BUILD_DIR}/assetcatalog_generated_info.plist&quot;&apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &quot;w&quot;) {|file| file.puts new_contents }
end

//如果有多个TARGETS，遍历执行即可
post_install do |installer|
  installer.aggregate_targets.each do |target|
    copy_pods_resources_path = &quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&quot;
    string_to_replace = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot;&apos;
    assets_compile_with_app_icon_arguments = &apos;--compile &quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&quot; --app-icon &quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&quot; --output-partial-info-plist &quot;${BUILD_DIR}/assetcatalog_generated_info.plist&quot;&apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &quot;w&quot;) {|file| file.puts new_contents }
  end
end
</code></pre><a id="more"></a>
<p>2.替换或者新添加文件时工程找不到文件</p>
<p>具体表现为报错<code>symbol(s) not found for architecture x86_64</code>，这个是Xcode9没有在我们添加文件时将相关文件添加到编译配置当中，只需要在工程-&gt;TARGETS-&gt;Build Phases-&gt;Compile Sources当中手动添加进去即可</p>
<p>3.打包导出（Export）失败</p>
<p>表现为点击Xcode的导出（Export）时提示<code>The data couldn’t be read because it isn’t in the correct format.</code>或者使用Jenkins等用脚本打包提示如下错误：</p>
<pre><code>2017-10-20 11:42:44.254 xcodebuild[6983:599869] [MT] IDEDistribution: Step failed: &lt;IDEDistributionSigningAssetsStep: 0x7fa541fd34a0&gt;: Error Domain=IDEDistributionSigningAssetStepErrorDomain Code=0 &quot;Locating signing assets failed.&quot; UserInfo={NSLocalizedDescription=Locating signing assets failed.,
IDEDistributionSigningAssetStepUnderlyingErrors=(
    &quot;Error Domain=IDEProvisioningErrorDomain Code=9 \&quot;\&quot;PrePublish.app\&quot; requires a provisioning profile with the Push Notifications feature.\&quot; UserInfo={NSLocalizedDescription=\&quot;PrePublish.app\&quot; requires a provisioning profile with the Push Notifications feature., NSLocalizedRecoverySuggestion=Add a profile to the \&quot;provisioningProfiles\&quot; dictionary in your Export Options property list.}&quot;
)}
</code></pre><p>原因是Xcode9帮你添加了一个<code>Code Signing Style</code>的配置字段，该字段需要和<code>Automatically manage signing</code>对应，使用<code>Automatically manage signing</code>时该字段的值需要为<code>Automatic</code>，不使用<code>Automatically manage signing</code>时该字段的值需要为<code>Manual</code>，上述错误就是因为配置不对应导致的，修改对应即可。</p>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><p>1.主题</p>
<p>部分经典主题在Theme列表看不到，只需要点击theme列表下面的“+”号即可添加，具体位置为Xcode-&gt;Preferences-&gt;Fonts &amp; Colors-&gt;左侧Theme-&gt;“+”</p>
<p>2.移除模拟器边框</p>
<p>取消勾选Simulator-&gt;Window-&gt;Show Device Bezels</p>
<p>3.单击跳转方法定义</p>
<p>Xcode9给“cmd+单击”添加了一个菜单选项，可以提供更多操作，如下：<br><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20171011-1.png" alt="20171011-1"></p>
<p>如果我们想直接跳转到方法定义，我们可以直接“cmd+鼠标右键”，触摸板是“cmd+双指轻击”</p>
<p>如果还是习惯原来的“cmd+单击”的方式，也可以在Xcode-&gt;Preferences-&gt;Navigation-&gt;Command-click on Code中将选项修改为Jumps To Definition，这样“cmd+单击”就是直接跳转到代码定义了。<br><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20171011-3.png" alt="20171011-3"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Xcode9的正式版也使用了一段时间了，bug还是有点多的，总感觉好像是赶工出来的版本，刚开始用的时候还是有点痛苦的，下面就把这些点列出来，大家可以参考一下。&lt;/p&gt;
&lt;h3 id=&quot;BUG&quot;&gt;&lt;a href=&quot;#BUG&quot; class=&quot;headerlink&quot; title=&quot;BUG&quot;&gt;&lt;/a&gt;BUG&lt;/h3&gt;&lt;p&gt;1.APP图标不见了&lt;/p&gt;
&lt;p&gt;用Xcode9跑起来工程之后发现应用图标不见了，这个是因为CocoaPods的资源脚本有点问题，在Xcode9上资源位置异常，工程引用不到，解决方案是在Podfile添加如下hook代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;post_install do |installer|
    copy_pods_resources_path = &amp;quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&amp;quot;
    string_to_replace = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot;&amp;apos;
    assets_compile_with_app_icon_arguments = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot; --app-icon &amp;quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&amp;quot; --output-partial-info-plist &amp;quot;${BUILD_DIR}/assetcatalog_generated_info.plist&amp;quot;&amp;apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &amp;quot;w&amp;quot;) {|file| file.puts new_contents }
end

//如果有多个TARGETS，遍历执行即可
post_install do |installer|
  installer.aggregate_targets.each do |target|
    copy_pods_resources_path = &amp;quot;Pods/Target Support Files/Pods-[工程名]/Pods-[工程名]-resources.sh&amp;quot;
    string_to_replace = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot;&amp;apos;
    assets_compile_with_app_icon_arguments = &amp;apos;--compile &amp;quot;${BUILT_PRODUCTS_DIR}/${UNLOCALIZED_RESOURCES_FOLDER_PATH}&amp;quot; --app-icon &amp;quot;${ASSETCATALOG_COMPILER_APPICON_NAME}&amp;quot; --output-partial-info-plist &amp;quot;${BUILD_DIR}/assetcatalog_generated_info.plist&amp;quot;&amp;apos;
    text = File.read(copy_pods_resources_path)
    new_contents = text.gsub(string_to_replace, assets_compile_with_app_icon_arguments)
    File.open(copy_pods_resources_path, &amp;quot;w&amp;quot;) {|file| file.puts new_contents }
  end
end
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://yoursite.com/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>一行命令搞定工程图片浏览查找</title>
    <link href="http://yoursite.com/2017/09/12/%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%90%9E%E5%AE%9A%E5%B7%A5%E7%A8%8B%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2017/09/12/一行命令搞定工程图片浏览查找/</id>
    <published>2017-09-12T06:26:59.000Z</published>
    <updated>2018-04-04T06:49:37.321Z</updated>
    
    <content type="html"><![CDATA[<p>在项目开发过程中随着项目的逐渐增大，项目当中的图片资源会越来越多，而且有些时候因为命名不规范和人员的变动等原因会造成项目当中重复的图片资源越来越多，而且Xcode查看图片的方式也不集中，查找起来也不方便，这种情况下我们往往会更倾向于添加一个新的图片资源，从而更加剧了图片资源重复的问题。</p>
<p>为了解决这个问题，我们打算来写一个脚本，把工程当中图片数据扫描一遍，然后用html集中显示出来，这样就方便我们来查找了。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>我们基本上需要解决以下3个问题</p>
<ol>
<li>工程资源文件扫描脚本的编写</li>
<li>html展示页面的编写</li>
<li>html页面和扫描脚本的数据交互</li>
</ol>
<p>1和2两点查阅相关资料就可以比较容易解决，主要是第3点，一般情况下浏览器是不提供操作文件的接口的，网上说的<code>ActiveXObject</code>也只是IE浏览器提供。这个地方我们采用了一个比较特殊的方式，就是将脚本扫描得到的数据直接利用脚本的文件操作写成一个js文件，虽然浏览器不能操作文件，但是可以直接读取js文件，这样就比较好的解决了脚本和html交互的问题。<a id="more"></a></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>脚本采用python实现，是一个递归查找并记录的过程，代码整体逻辑并不复杂，表现层的html也都是比较简单的原生html代码和js代码，这里就不做详细介绍了，我们简单的看下检查依赖和数据交互的逻辑。</p>
<p>下面这段代码就是检查依赖的方法，以前都是在文档当中提示使用者手动安装，现在我们可以用这样一个方法检索用户的特定库的安装列表，如果没有安装相应库，则执行相应命令帮其安装。</p>
<pre><code>def checkDepend():
    print &quot;检查依赖库...&quot;
    isHavePillow = False
    r = os.popen(&quot;pip freeze&quot;)
    x = r.readlines()
    for line in x:
        if line.startswith(&quot;Pillow=&quot;):
            isHavePillow = True
    if isHavePillow:
        print &quot;依赖库存在&quot;
    else:
        print &quot;依赖库不存在，安装依赖库...&quot;
        os.system(&quot;sudo pip install Pillow&quot;)
        print &quot;依赖库安装完成&quot;
</code></pre><p>下面这个方法就是将检索到数据生成js的方法，我们可以看到它是直接将数组当中的内容转化为json并拼接成一个赋值给imageData变量的字符串，利用python的文件操作，将此字符串写入一个名为imageData.js的文件当中，这样就可以被html引用并操作imageData变量了。</p>
<pre><code>def generateJSFile(mArrImageData):
    if os.path.exists(&quot;./imageData.js&quot;):
        os.remove(&quot;./imageData.js&quot;)
    f = open(&quot;./imageData.js&quot;, &apos;w&apos;)
    strJson = json.dumps({&quot;data&quot;:mArrImageData})
    strDes = &quot;var imageData = &quot; + strJson
    # print strJson
    f.write(strDes)
    f.close()
</code></pre><p>源代码请戳这里<a href="https://github.com/yangzq007/SHScript/tree/master/FindImage" target="_blank" rel="external">FindImage</a>。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>将源代码clone或者下载到本地，并根据README当中提示修改<code>path</code>为自己的工程目录，然后执行下面命令，脚本便会帮你检索并打开相应的浏览页面，轻松一行命令搞定。</p>
<pre><code>python findImage.py
</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>html5提供了读取文件的API——FileReader，利用它来实现数据交互也是一个不错的选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目开发过程中随着项目的逐渐增大，项目当中的图片资源会越来越多，而且有些时候因为命名不规范和人员的变动等原因会造成项目当中重复的图片资源越来越多，而且Xcode查看图片的方式也不集中，查找起来也不方便，这种情况下我们往往会更倾向于添加一个新的图片资源，从而更加剧了图片资源重复的问题。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们打算来写一个脚本，把工程当中图片数据扫描一遍，然后用html集中显示出来，这样就方便我们来查找了。&lt;/p&gt;
&lt;h3 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h3&gt;&lt;p&gt;我们基本上需要解决以下3个问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工程资源文件扫描脚本的编写&lt;/li&gt;
&lt;li&gt;html展示页面的编写&lt;/li&gt;
&lt;li&gt;html页面和扫描脚本的数据交互&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1和2两点查阅相关资料就可以比较容易解决，主要是第3点，一般情况下浏览器是不提供操作文件的接口的，网上说的&lt;code&gt;ActiveXObject&lt;/code&gt;也只是IE浏览器提供。这个地方我们采用了一个比较特殊的方式，就是将脚本扫描得到的数据直接利用脚本的文件操作写成一个js文件，虽然浏览器不能操作文件，但是可以直接读取js文件，这样就比较好的解决了脚本和html交互的问题。
    
    </summary>
    
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>一个优雅的水波动画</title>
    <link href="http://yoursite.com/2017/08/11/%E4%B8%80%E4%B8%AA%E4%BC%98%E9%9B%85%E7%9A%84%E6%B0%B4%E6%B3%A2%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2017/08/11/一个优雅的水波动画/</id>
    <published>2017-08-11T02:51:04.000Z</published>
    <updated>2018-12-29T03:11:38.892Z</updated>
    
    <content type="html"><![CDATA[<p>今天整理文件的时候发现以前写的一个动画，感觉还不错，就和大家分享一下。</p>
<p>如何实现一个如下图的动画呢？</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170811-1.gif" alt="20170811-1"></p>
<p>下面我们就来一步步的实现它。<a id="more"></a></p>
<h3 id="动画拆解"><a href="#动画拆解" class="headerlink" title="动画拆解"></a>动画拆解</h3><p>做一个复杂的东西的时候，我们需要将它拆解成若干个容易实现的细节，之后在将这些细节有序的累加起来就可以实现我们最初的复杂的结构，没准当你完成的时候自己都会发出It’s amazing的感叹。</p>
<p>来看这个动画，我们发现有两个主要元素，一个是晃动水波线，一个是由于水深造成的颜色渐变。那我们得到了第一个容易实现的细节点：</p>
<p>1.水深的颜色渐变</p>
<p>晃动的水波线对我们来说似乎并不是一个简单的元素，那我们再来拆解，或许你注意到了这是一个正弦曲线的水平移动，只是这个正弦曲线稍微有点特殊，加入了一些浮动波峰和波谷的参数。那么我们得到了第二个细节点：</p>
<p>2.水波正弦曲线</p>
<p>同时也确定了第三个细节点：</p>
<p>3.正弦曲线模拟波浪参数方式</p>
<p>然后我们还有一个工作要做，就是以上元素以何种方式组织起来，这也是第四个点：</p>
<p>4.以上元素的组织方式</p>
<h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>要实现这个动画的话我们先要来谈谈第4点，因为你不能将你分解的元素有效的组织起来的话我们的动画就不能实现。其实在动画拆解的时候，我们心里就要对第4点心中有数了，这是一个慢慢积累经验的过程，当然我们可以参考别人。</p>
<p>针对于第4点，我们的实现方式是用第2点和第3点实现的曲线设置成一个mask，去遮罩一个颜色有渐变的矩形区域（第1点），这样就得到了我们想要的波浪。想要波浪动起来，我们让波浪曲线随着时间发生变化即可。要做成效果当中的三条波浪，只需要将这些元素放置3份即可，只是设置参数不同罢了。</p>
<p>下面我们来分别实现上面拆解的细节点：</p>
<p>针对第1点，我们采用<code>CAGradientLayer</code>来实现，你不仅设置它从某个颜色渐变到另外一个颜色，而且还可以设置它的渐变方向等等。下面几行代码就可以实现我们想要的效果。</p>
<pre><code>_firstGradientLayer = [CAGradientLayer layer];
_firstGradientLayer.frame = CGRectMake(0, sc_screenSize.height-(FirstWaveCenterHeight*BEI6+FirstWaveAmplitude*BEI6), sc_screenSize.width, FirstWaveCenterHeight*BEI6+FirstWaveAmplitude*BEI6);
[_firstGradientLayer setColors:[NSArray arrayWithObjects:(id)[[UIColor colorWithRed:122.0f/255.0f green:95.0f/255.0f blue:233.0f/255.0f alpha:1] CGColor],(id)[[UIColor colorWithRed:70.0f/255.0f green:221.0f/255.0f blue:220.0f/255.0f alpha:1] CGColor], nil]];
[_firstGradientLayer setStartPoint:CGPointMake(0, 0)];
[_firstGradientLayer setEndPoint:CGPointMake(0, 1)];
[self.view.layer addSublayer:_firstGradientLayer];
</code></pre><p>效果如下：</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170811-2.png" alt="20170811-2"></p>
<p>对于第2点，就要用到我们高中的知识了，对于屏幕上的每一个x值，计算出对应的y值，并将它们连接起来。其中<code>FirstWaveSpeed*BEI6*_firstWaveTime</code>是为了让波浪曲线随时间变化，产生向右平移运动的效果，<code>_firstVariable</code>这个属性是第3点当中要实现的更好的模拟波浪效果的参数，我们下面再进行介绍。</p>
<pre><code>- (CGMutablePathRef)getFirstCurrentWavePath
{
    CGMutablePathRef path = CGPathCreateMutable();
    CGPathMoveToPoint(path, nil, 0, FirstWaveCenterHeight*BEI6);

    float y = 0.0f;

    for (float x = 0.0f; x &lt;=  sc_screenSize.width ; x++) {
        // 正弦波浪公式
        y = FirstWaveAmplitude*BEI6 + FirstWaveAmplitude*BEI6* sin(_firstWaveCircle*x-FirstWaveSpeed*BEI6*_firstWaveTime)*_firstVariable;
        CGPathAddLineToPoint(path, nil, x, y);
    }

    CGPathAddLineToPoint(path, nil, sc_screenSize.width, sc_screenSize.height);
    CGPathAddLineToPoint(path, nil, 0, sc_screenSize.height);
    CGPathCloseSubpath(path);
    return path;
}
</code></pre><p>下面我们来看3点，为了更好的模拟波浪的效果，我们需要一个曲线振幅的变化，我这里只做了简单的随时间在设定的范围内增大和变小的操作，如果想要更好的效果，可以添加更多参数来控制，当然这也需要一些物理学的知识。</p>
<pre><code>-(void)animateFirstWave
{
    if (_firstIncrease) {
        _firstVariable += 0.01;
    }else{
        _firstVariable -= 0.01;
    }

    if (_firstVariable&lt;=0.4) {
        _firstIncrease = YES;
    }

    if (_firstVariable&gt;=0.8) {
        _firstIncrease = NO;
    }
}
</code></pre><p>以上基本元素都已经准备好了，那我们来做第4点，将上述元素整合起来。我们用<code>CAShapeLayer</code>来为第1点实现的渐变色提供提供遮罩。</p>
<pre><code>_firstWaveLayer = [CAShapeLayer layer];
_firstWaveLayer.fillColor = [UIColor whiteColor].CGColor;

[_firstGradientLayer setMask:_firstWaveLayer];

//当然别忘记把我们计算好的曲线给设置上去
_firstWaveLayer.path = [self getFirstCurrentWavePath];
</code></pre><p>这样我们就得到了一个静态的波浪</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170811-3.png" alt="20170811-3"></p>
<p>想要波浪动起来，我们要为它加入上面提到的时间变量<code>_firstWaveTime</code>，一般情况下我们加入时间变量都会采用<code>NSTimer</code>来进行计时，但是此处我们使用<code>CADisplayLink</code>来进行定时操作。为什么使用<code>CADisplayLink</code>呢，因为<code>CADisplayLink</code>的调用频率是和屏幕的刷新频率一致的，这样的话不会出现<code>NSTimer</code>那种由于和屏幕刷新时间冲突造成的渲染滞后画面卡顿的现象。</p>
<pre><code>- (void)initTimer
{
    _firstWaveDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(setWaveLayer)];
    [self setWaveLayer];
}

- (void)setWaveLayer
{
    [self firstWaveTimeCount];
    [self animateFirstWave];
    _firstWaveLayer.path = [self getFirstCurrentWavePath];
}

//_firstCircleTime是波浪的一个时间周期，超过一个时间周期，重复上个周期的操作。
//为了了方便设置波浪的方便设置设置波浪的的速度和周期引入的此参数。
- (void)firstWaveTimeCount
{
    _firstWaveTime++;
    _firstWaveTime = _firstWaveTime%_firstCircleTime;
}
</code></pre><p>这样我们就得到了第一个流动的波浪</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170811-4.gif" alt="20170811-4"></p>
<p>下面只要在重复添加两条线就可以得到我们想要的效果了，不过，需要注意的是第三条波浪的颜色渐变是从左到右的哦，当然这是一个小问题。</p>
<h3 id="动画调整"><a href="#动画调整" class="headerlink" title="动画调整"></a>动画调整</h3><p>大部分情况下，我们写出来的复杂动画都会和设计师想要的样子有一定差距，当然也不排除能拿到精准参数的情况，但毕竟让一个设计师告诉你正弦曲线的起始位置不太现实，这个时候我们需要把能控制这个动画的一些参数单独写出来，不要用写死的值，其他的参数依赖于这些值，由这些值计算出来。这样我们就可以方便的调整动画的显示了，甚至可以让设计师自己动手调整出想要的样子。</p>
<pre><code>const static float FirstWaveCenterHeight = 162;
const static float FirstWaveAmplitude = 20.0f;//振幅比例
const static float FirstWaveNum = 1;//容纳曲线循环个数
const static float FirstWaveSpeed = 0.05f;//波浪速度
</code></pre><p>源码：<a href="https://github.com/yangzq007/SHDemo" target="_blank" rel="external">https://github.com/yangzq007/SHDemo</a>-&gt;水波动画</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天整理文件的时候发现以前写的一个动画，感觉还不错，就和大家分享一下。&lt;/p&gt;
&lt;p&gt;如何实现一个如下图的动画呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170811-1.gif&quot; alt=&quot;20170811-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我们就来一步步的实现它。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS工程文件整理</title>
    <link href="http://yoursite.com/2017/07/31/iOS%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2017/07/31/iOS工程文件整理/</id>
    <published>2017-07-31T02:17:30.000Z</published>
    <updated>2018-12-29T03:11:38.891Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发过程的当中不知道大家有没有遇到过这样的问题</p>
<ol>
<li>文件的物理位置不对应</li>
<li>多余的未被工程引用的文件</li>
</ol>
<p>这两个问题在工程变得比较大的时候，对工程的影响就比较让人难受了，于是我决定对工程进行整理。</p>
<p>因为我们的业务还是蛮复杂的，工程就特别大，手动查找和整理简直就是一场灾难，于是我决定使用脚本来帮助我完成这项虽然简单但是巨大的工程。<a id="more"></a></p>
<h3 id="文件物理位置不对应的原因"><a href="#文件物理位置不对应的原因" class="headerlink" title="文件物理位置不对应的原因"></a>文件物理位置不对应的原因</h3><p>说到这个问题，我们就需要提一下project.pbxproj文件了，对，就是那个每次合并冲突都让人头疼的文件。</p>
<p><a href="http://www.monobjc.net/xcode-project-file-format.html" target="_blank" rel="external">project.pbxproj</a>文件本质上是一种旧风格的plist，因为可读性不是很好，逐渐被弃用，但是苹果却一直沿用，在这个文件当中包含了Xcode工程的各项配置和参数。project.pbxproj文件采用UDID作为key索引来保证文件的唯一性，同时又在value当中指定其对应子节点的UDID值，这样就将一个树形结构的数据用列表形式表示了出来（UDID是根据硬件和时间戳生成的唯一标识，这里不再详细解释其过程），工程的虚拟文件目录就是这么来的。</p>
<p>下面是一个转换成标准plist的结构，我们可以看到它的引用方式</p>
<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170731-1.png" alt="20170731-1"></p>
<p>因此我们解决物理位置不对应的问题只需要读取project.pbxproj的虚拟目录，并检查当前目录下是否有该文件，如果没有，到其对应的物理路径下，将其剪切过来即可。</p>
<p>针对第二个问题，我们可以扫描工程的整个物理目录，将每个文件去虚拟目录当中查找，如果没有被引用，直接删除即可。</p>
<h3 id="脚本的编写"><a href="#脚本的编写" class="headerlink" title="脚本的编写"></a>脚本的编写</h3><p>我们使用python来完成这次的任务，为什么不用shell？因为bash 3不支持key-value结构，要升级到bash 4才可以，而python比较方便，就使用它了，推荐使用python 3，因为它简化了蛮多操作的，比如编码什么的，不推荐使用预装的python 2。</p>
<p>1.读取project.pbxproj</p>
<p>我们先需要使用以下命令将project.pbxproj转换成标准的plist，然后使用python库<code>biplist</code>读取</p>
<pre><code>value=`plutil -convert xml1 -o - project.pbxproj` &amp;&amp; echo $value &gt;mPlistPath
</code></pre><p>2.检查虚拟目录下对应的文件是否存在，并进行相应操作</p>
<p>3.扫描工程物理路径，检查文件是否被引用，并进行操作</p>
<p>脚本如下：</p>
<pre><code># !/usr/bin/python
# coding=utf-8

from biplist import *
import os

global rootObjects
global rootArr
global plistPath

####################变量设置区#################################
rootPath= &quot;/Users/yzq/Desktop/Test/Test&quot;
projectFilePath = &quot;/Users/yzq/Desktop/Test/Test.xcodeproj&quot;
plistPath = &quot;/Users/yzq/Desktop/123.plist&quot;
##############################################################

def checkfile(filePath,filekey):
    global rootObjects

    dic = rootObjects[filekey]
    # print(filekey) 

    strPath = &quot;&quot;
    if &quot;path&quot; in dic:
        strPath = dic[&quot;path&quot;]
    else:
        strPath = dic[&quot;name&quot;]

    path = filePath + &quot;/&quot; + strPath
    if &quot;children&quot; in dic:
        if len(dic[&quot;children&quot;]) &lt; 1:
            print(&quot;空文件夹&quot;+&quot;------&quot;+path)
        else:
            for item in dic[&quot;children&quot;]:
                checkfile(path,item)
    else:
        if os.path.exists(path) == False:
            print(&quot;文件不存在&quot;+path)


def startCheckFile(mRootPath):
    global rootObjects
    global plistPath

    plist = readPlist(plistPath)
    rootObjects = plist[&quot;objects&quot;]

    for dic in rootObjects.values():
        if (&quot;name&quot; in dic) and dic[&quot;name&quot;] == &quot;dfc_v3&quot;:
            rootArr = dic[&quot;children&quot;]
            break

    print(rootArr)

    for item in rootArr:
        print(&quot;开始检查item&quot;+item+&quot;-------------------------------&quot;)
        checkfile(mRootPath,item)


def checkFileIsInProject(mPlistObject, mFileName, mFilePath):
    for item in mPlistObject.values():
        if ((&quot;path&quot; in item) and (item[&quot;path&quot;] == mFileName)) or ((&quot;name&quot; in item) and (item[&quot;name&quot;] == mFileName)):
            # print(&quot;发现文件引用&quot;+mFileName)
            return
    print(&quot;未发现文件应用：&quot;+mFileName)
    print(mFilePath)


def checkProject(mPlistObject, mFilePath):
    dirList = os.listdir(mFilePath)
    for item in dirList:
        itemPath = os.path.join(mFilePath,item)
        if os.path.isfile(itemPath):
            checkFileIsInProject(mPlistObject,item,itemPath)
        elif os.path.isdir(itemPath):
            checkProject(mPlistObject,itemPath)
        else:
            print(&quot;当前路径出错:&quot;+itemPath)


def startCheckProject(mRootPath):
    global plistPath

    plist = readPlist(plistPath)
    rootObjects = plist[&quot;objects&quot;]

    checkProject(rootObjects,mRootPath)


def getPlist(mProjectFilePath,mPlistPath):
    command = &quot;rm -rf &quot;+mPlistPath
    os.system(command)
    command = &quot;value=`plutil -convert xml1 -o - &quot;+mProjectFilePath+&quot;/project.pbxproj` &amp;&amp; echo $value &gt;&quot;+mPlistPath
    os.system(command)
    print(&quot;生成plist文件:&quot;+mPlistPath)


print(&quot;这是一个帮你检查工程文件的脚本，请输入以下数字选项执行&quot;)
print(&quot;0.准备工作&quot;)
print(&quot;1.检查工程列表当中的文件是否在对应的物理位置&quot;)
print(&quot;2.检查工程当中是否有文件未加入引用&quot;)
choice = input(&quot;请输入:&quot;)
if choice == &quot;0&quot;:
    print(&quot;请设置脚本rootPath、projectFilePath、plistPath三个变量的路径值&quot;)
    print(&quot;rootPath：工程根目录，dfc_v2的那个文件夹目录&quot;)
    print(&quot;projectFilePath：工程文件目录,dfc_v2.xcodeproj文件目录&quot;)
    print(&quot;plistPath：生成plist文件所在位置，该位置任意，具备读写权限即可&quot;)
elif choice == &quot;1&quot;:
    getPlist(projectFilePath,plistPath)
    startCheckFile(rootPath)
elif choice == &quot;2&quot;:
    getPlist(projectFilePath,plistPath)
    startCheckProject(rootPath)
else:
    print(&quot;未输入正确的操作&quot;)
</code></pre><p>因为贸然的使用脚本改动工程有一定的风险，所以我在脚本当中把有问题的文件及其目录输出，手动去改动。</p>
<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><p>执行脚本，让后根据输出的结果修改工程，因为<code>Supporting Files</code>下的文件直接是在主目录下的，它下面的文件直接忽略即可。</p>
<pre><code>python3 my.py
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发过程的当中不知道大家有没有遇到过这样的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件的物理位置不对应&lt;/li&gt;
&lt;li&gt;多余的未被工程引用的文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两个问题在工程变得比较大的时候，对工程的影响就比较让人难受了，于是我决定对工程进行整理。&lt;/p&gt;
&lt;p&gt;因为我们的业务还是蛮复杂的，工程就特别大，手动查找和整理简直就是一场灾难，于是我决定使用脚本来帮助我完成这项虽然简单但是巨大的工程。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="Xcode" scheme="http://yoursite.com/tags/Xcode/"/>
    
      <category term="脚本" scheme="http://yoursite.com/tags/%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>React Native之mobx绑定</title>
    <link href="http://yoursite.com/2017/07/12/React-Native%E4%B9%8Bmobx%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2017/07/12/React-Native之mobx绑定/</id>
    <published>2017-07-12T08:53:33.000Z</published>
    <updated>2018-04-04T06:52:18.171Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个iOS开发，想必大家都经历过把很多状态和逻辑放到Controller当中的时候，当Controller逐渐变大，数据处理逻辑、视图展示逻辑和状态控制逻辑混在一起会导致代码越来越难维护，RN当中的State也会存在这样的问题，我们引入mobx就是为了解决这样的问题。</p>
<blockquote>
<p>MobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。</p>
</blockquote>
<p>mobx通过响应式的结构将数据和视图的处理逻辑进行分离，比较好的解决了状态维护的问题，再将数据处理分离出去就是一个标准的MVVM的结构，开发者在VM当中对数据和视图进行了绑定后就可以只关心视图的渲染和数据的处理了，这样也更容易理解。<a id="more"></a></p>
<h3 id="mobx的使用"><a href="#mobx的使用" class="headerlink" title="mobx的使用"></a>mobx的使用</h3><p>使用前，首先我们要安装下</p>
<pre><code>npm install mobx --save
npm install mobx-react --save    //React 绑定库
</code></pre><p>然后是分别在数据绑定文件和视图文件当中中添加装饰器绑定，下面是部分示例代码</p>
<pre><code>//数据绑定文件
import { computed, observable } from &apos;mobx&apos;;

class IndexStore {
    @observable listData = [];
}

//视图文件
import { observer } from &apos;mobx-react/native&apos;;
import IndexStore from &apos;indexStore&apos;;

@observer
class Index extends Component {
    constructor() {
        super();
        this.store = new IndexStore();
    }

    render() {
    return (
        &lt;MainItem dataSource={this.store.listData}
        renderHeader={
            () =&gt; &lt;Item data={this.store}&gt;&lt;/Item&gt;
        } /&gt;
    )
}
</code></pre><h3 id="mobx的绑定过程"><a href="#mobx的绑定过程" class="headerlink" title="mobx的绑定过程"></a>mobx的绑定过程</h3><p>mobx在建立绑定时先将视图的render()走一遍，收集视图和被观察数据的关联，并将这些关联储存起来。当数据源发生变化之后，mbox就根据这些对应的关联，刷新对应的视图。</p>
<p>需要注意的是以下两种情况，对应的视图和关联不会被收集到：</p>
<p>1.赋值给属性的函数当中的关联不会在当前视图中收集</p>
<p>比如上面实例当中的renderHeader属性赋值的函数<code>() =&gt; &lt;Item data={this.store}&gt;&lt;/Item&gt;</code>，因为Item作为返回值返回，并不属于该视图当中的渲染。不过store当中的数据可以在Item当中的渲染中绑定，但需要你在Item中添加@observer.</p>
<p>2.直接使用被观察变量的值，未出现对应的引用</p>
<p>比如在Item当中添加了@observer，但是直接将被被观测变量的值赋值给了Item也是无法建立关联的，比如下面这种写法</p>
<pre><code>renderHeader={
    () =&gt; &lt;Item data={this.store.listData}&gt;&lt;/Item&gt;
}
</code></pre><p>这样被观测变量的值赋了过去，在Item的render当中并没有被观察变量引用，这样mobx认为是没有被观察数据使用的。正确的方法是像实例当中那样把被观测数据的父级引用传递过去，在Item当中使用父级引用来引用被观察变量来使用。</p>
<p>只要注意了以上两种情况，mobx的绑定基本就没有什么大问题了，接下来就是享受mobx给你带来的便利了。</p>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>绑定建立完成后，需要注意被观察的变量引用发生变化时必须是一个新值，指向一个新的地址，直接修改变量当中的值并不会让被观察变量的值发生变化，界面并不会刷新。</p>
<pre><code>class IndexStore {
    //this.listData的值没有变化，界面不会刷新
    this.listData[0] = &quot;1&quot;;

    //this.listData是一个新值，界面刷新
    this.listData = [&quot;1&quot;];
}
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个iOS开发，想必大家都经历过把很多状态和逻辑放到Controller当中的时候，当Controller逐渐变大，数据处理逻辑、视图展示逻辑和状态控制逻辑混在一起会导致代码越来越难维护，RN当中的State也会存在这样的问题，我们引入mobx就是为了解决这样的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MobX 是一个经过战火洗礼的库，它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;mobx通过响应式的结构将数据和视图的处理逻辑进行分离，比较好的解决了状态维护的问题，再将数据处理分离出去就是一个标准的MVVM的结构，开发者在VM当中对数据和视图进行了绑定后就可以只关心视图的渲染和数据的处理了，这样也更容易理解。
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>React Native之如何写一个ListView</title>
    <link href="http://yoursite.com/2017/07/05/React-Native%E4%B9%8B%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AAListView/"/>
    <id>http://yoursite.com/2017/07/05/React-Native之如何写一个ListView/</id>
    <published>2017-07-05T03:11:43.000Z</published>
    <updated>2018-04-04T06:52:38.483Z</updated>
    
    <content type="html"><![CDATA[<p>写RN也有段时间了，今天抽空就对RN当中的ListView进行一个简单介绍，主要介绍使用当中的一些坑。</p>
<h3 id="写一个简单的ListView"><a href="#写一个简单的ListView" class="headerlink" title="写一个简单的ListView"></a>写一个简单的ListView</h3><pre><code>class MyComponent extends Component {
  constructor() {
    super();
    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2});
    this.state = {
      dataSource: ds.cloneWithRows([&apos;row 1&apos;, &apos;row 2&apos;]),
    };
  }

  render() {
    return (
      &lt;ListView
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&gt; &lt;Text&gt;{rowData}&lt;/Text&gt;}
      /&gt;
    );
  }
}
</code></pre><a id="more"></a>
<p>以上代码就可以绘制一个简单的ListView了，但是我们需要注意<code>dataSource: ds.cloneWithRows([&#39;row 1&#39;, &#39;row 2&#39;])</code>这一行，因为我们的数据一般都是网络请求来的，所以我们一般可能会写成这样</p>
<pre><code>listData = [];

constructor() {
    super();
    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&gt; r1 !== r2});
    this.state = {
      dataSource: ds.cloneWithRows(this.listData),
    };
  }

  ***省略的网络请求***
  listData = [&apos;row 1&apos;, &apos;row 2&apos;];
  ***省略的更新state***
</code></pre><p>然而你发现你的ListView并没有更新，还是一片空白,当我们把<code>dataSource: ds.cloneWithRows(this.listData)</code>这一行改成<code>dataSource: ds.cloneWithRows(this.listData.slice())</code>你会发现问题解决了，why?</p>
<p>这是因为这样只是一个浅拷贝，虽然数组内容发生了变化，但是<code>ds.cloneWithRows</code>接收到的数据没有发生变，故页面会刷新。当我们用<code>slice</code>时，给它返回一个新值，这样界面就会重新刷新渲染。</p>
<h3 id="写一个带Section的ListView"><a href="#写一个带Section的ListView" class="headerlink" title="写一个带Section的ListView"></a>写一个带Section的ListView</h3><p>要写一个带Section的ListView主要是针对数据源的改造。</p>
<p>DataSource构造函数可以接受下列四种参数（都是可选）：</p>
<pre><code>getRowData(dataBlob, sectionID, rowID);
getSectionHeaderData(dataBlob, sectionID);
rowHasChanged(prevRowData, nextRowData);
sectionHeaderHasChanged(prevSectionData, nextSectionData);
</code></pre><p>如果不提供getRowData和getSectionHeaderData方法，使用defaultGetRowData和defaultGetSectionHeaderData来提取数据，默认的提取函数可以处理的数据结构如下：</p>
<pre><code>{ sectionID_1: { rowID_1: rowData1, ... }, ... }
或者
{ sectionID_1: [ rowData1, rowData2, ... ], ... }
或者
[ [ rowData1, rowData2, ... ], ... ]
</code></pre><p>我们用第二种数据结构来实现：</p>
<pre><code>class MyComponent extends Component {
  constructor() {
    super();

    listData = { &quot;1&quot;: [ &quot;11&quot;, &quot;12&quot;], &quot;2&quot;: [ &quot;21&quot;, &quot;22&quot;] };

    const ds =  new ListView.DataSource({
        rowHasChanged: (r1, r2) =&gt; r1 !== r2,
        sectionHeaderHasChanged: (s1, s2) =&gt; s1 != s2
    });
    this.state = {
      dataSource: ds.cloneWithRowsAndSections(
              this.listData,
              Object.keys(this.listData),
              Object.keys(this.listData).map(
            (sectionId) =&gt; Object.keys(
                this.listData[sectionId].slice()
            )
        )
      ),
    };
  }

  render() {
    return (
      &lt;ListView
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&gt; &lt;Text&gt;{rowData}&lt;/Text&gt;}
      /&gt;
    );
  }
}
</code></pre><p>需要注意的是<code>cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities)</code>方法当中的参数也需要是一个新值，所以<code>rowIdentities</code>参数的数据也需要<code>slice()</code>一下，回传一个新值。</p>
<p>当需要将sectionHeader的样式显示出来，还需要在render当中添加关于header渲染的代码</p>
<pre><code>render() {
    return (
      &lt;ListView
           renderSectionHeader={
                (sectionData, sectionID) =&gt; &lt;Text&gt;{sectionID}&lt;/Text&gt;
        }
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&gt; &lt;Text&gt;{rowData}&lt;/Text&gt;}
      /&gt;
    );
  }
</code></pre><p>这样一个带section的ListView就写出来了。</p>
<h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><ol>
<li>React Native不支持随ListView滚动的Header，如果需要，请在每个section当中的第一个Item当中添加</li>
<li>如果ListView要下拉一下才显示出来，请设置ListView的属性<code>removeClippedSubviews={false}</code></li>
<li>如果在iOS设备上ListView距离顶部导航栏有距离，请设置ListView的属性<code>automaticallyAdjustContentInsets={false}</code></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写RN也有段时间了，今天抽空就对RN当中的ListView进行一个简单介绍，主要介绍使用当中的一些坑。&lt;/p&gt;
&lt;h3 id=&quot;写一个简单的ListView&quot;&gt;&lt;a href=&quot;#写一个简单的ListView&quot; class=&quot;headerlink&quot; title=&quot;写一个简单的ListView&quot;&gt;&lt;/a&gt;写一个简单的ListView&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;class MyComponent extends Component {
  constructor() {
    super();
    const ds = new ListView.DataSource({rowHasChanged: (r1, r2) =&amp;gt; r1 !== r2});
    this.state = {
      dataSource: ds.cloneWithRows([&amp;apos;row 1&amp;apos;, &amp;apos;row 2&amp;apos;]),
    };
  }

  render() {
    return (
      &amp;lt;ListView
        dataSource={this.state.dataSource}
        renderRow={(rowData) =&amp;gt; &amp;lt;Text&amp;gt;{rowData}&amp;lt;/Text&amp;gt;}
      /&amp;gt;
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="ReactNative" scheme="http://yoursite.com/tags/ReactNative/"/>
    
  </entry>
  
  <entry>
    <title>文档网站生成工具docsify</title>
    <link href="http://yoursite.com/2017/06/20/%E6%96%87%E6%A1%A3%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7docsify/"/>
    <id>http://yoursite.com/2017/06/20/文档网站生成工具docsify/</id>
    <published>2017-06-20T09:58:08.000Z</published>
    <updated>2018-12-29T03:11:38.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170620-1.png" alt="20170620-1"></p>
<p>今天给大家推荐一个非常好用的工具docsify，对，没错，就是上面这个萌萌哒的类似果冻的东西。</p>
<h3 id="docsify"><a href="#docsify" class="headerlink" title="docsify"></a>docsify</h3><p>docsify是一个非常好用的文档网站生成工具。它能快速的将你存储在Git仓库中的markdown文档生成一个文档网站，而且界面非常美观。</p>
<p>下面是docsify文档的介绍</p>
<blockquote>
<p>docsify 是一个动态生成文档网站的工具。不同于 GitBook、Hexo 的地方是它不会生成将 .md 转成 .html 文件，所有转换工作都是在运行时进行。</p>
<p>这将非常实用，如果只是需要快速的搭建一个小型的文档网站，或者不想因为生成的一堆 .html 文件“污染” commit 记录，只需要创建一个 index.html 就可以开始写文档而且直接部署在 GitHub Pages。</p>
</blockquote>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>直接点击<a href="https://docsify.js.org/#/" target="_blank" rel="external">这里</a>查看其官方文档即可，里面非常详细的介绍了如何使用。另外<a href="https://docsify.js.org/#/zh-cn/" target="_blank" rel="external">docsify文档</a>也是一个实例demo。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://shuhai-1258408332.cos.ap-chengdu.myqcloud.com/20170620-1.png&quot; alt=&quot;20170620-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天给大家推荐一个非常好用的工具docsify，对，没错，就是上
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>iOS下的cookies使用</title>
    <link href="http://yoursite.com/2017/05/27/iOS%E4%B8%8B%E7%9A%84cookies%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/05/27/iOS下的cookies使用/</id>
    <published>2017-05-27T08:21:36.000Z</published>
    <updated>2018-04-04T07:01:45.987Z</updated>
    
    <content type="html"><![CDATA[<p>今天无意间翻到了以前有关cookies的代码，就顺便整理了一下，和大家分享下。</p>
<h3 id="Cookies简介"><a href="#Cookies简介" class="headerlink" title="Cookies简介"></a>Cookies简介</h3><p>这里有比较详细的介绍，本文就不再赘述了。<a href="http://blog.csdn.net/fangaoxin/article/details/6952954" target="_blank" rel="external">click me</a></p>
<p>在iOS当中需要注意以下几点：</p>
<ol>
<li>不管是NSURLConnection还是UIWebView都会保留并传递服务端的cookie，就是说基本所有的网络请求都会使用cookie</li>
<li>多个应用之间默认不共享cookie</li>
<li>临时cookie在应用重启之后就会消失</li>
<li>持久cookie在应用或系统重启之后不会消失</li>
<li>cookie不能跨域，像.baidu.com和image.baidu.com这种也是跨域</li>
<li>WKWebView因为没有缓存，不能使用cookie，想要使用，需做特殊处理。</li>
</ol>
<p>注：cookie不能跨域是通用的，在所有情况下都是这样，并非在iOS系统上如此。.baidu.com和image.baidu.com可以使用彼此的cookie是因为服务端做了特殊的处理。<a id="more"></a></p>
<h3 id="Cookies操作"><a href="#Cookies操作" class="headerlink" title="Cookies操作"></a>Cookies操作</h3><p>iOS系统当中的cookies由系统底层实现和使用，同时提供了<code>NSHTTPCookieStorage</code>和<code>NSHTTPCookie</code>来统一操作cookie。<code>NSHTTPCookieStorage</code>是一个单例，我们所有的cookies都存放在这里，当我们发起网络请求时，系统会默认从<code>NSHTTPCookieStorage</code>当中匹配相应cookie并带上去，所以我们只需要操作<code>NSHTTPCookieStorage</code>即可。</p>
<p>以下是一些简单的使用</p>
<pre><code>/**
 *  获得url对应的cookie
 *
 *  @param url url
 *
 *  @return url对应的cookie
 */
- (NSArray *)getCookiesForUrl:(NSString *)url
{
    NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

    if ([sharedHTTPCookieStorage cookieAcceptPolicy] != NSHTTPCookieAcceptPolicyAlways) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];
    }

    NSArray *cookies = [sharedHTTPCookieStorage cookiesForURL:[NSURL URLWithString:url]];

    return cookies;
}

/**
 *  获取应用下所有的cookie
 *
 *  @return 所有的cookie
 */
- (NSArray *)getAllCookies
{
    NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

    if ([sharedHTTPCookieStorage cookieAcceptPolicy] != NSHTTPCookieAcceptPolicyAlways) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];
    }

    return sharedHTTPCookieStorage.cookies;
}

/**
 *  将cookie数组当中的cookie设置到cookie缓存中
 *
 *  @param mArrCookie cookie数组
 */
- (void)setCookiesFromArr:(NSArray *)mArrCookie
{
    if (mArrCookie != nil &amp;&amp; [mArrCookie count]&gt;0) {
        NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

        for (NSHTTPCookie *cookie in mArrCookie) {
            [sharedHTTPCookieStorage setCookie:cookie];
        }
    }
}

/**
 *  为特殊的url设置cookie
 *
 *  @param mArrCookie cookie数组
 *  @param url        地址，此处地址格式需为.baidu.com这样
 */
- (void)setCookie:(NSArray *)mArrCookie forUrl:(NSString *)url
{
    if (mArrCookie != nil &amp;&amp; [mArrCookie count]&gt;0) {
        NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

        for (NSHTTPCookie *cookie in mArrCookie) {
            NSMutableDictionary *cookieDic = [NSMutableDictionary dictionaryWithDictionary:[cookie properties]];
            [cookieDic setObject:url forKey:@&quot;Domain&quot;];
            NSHTTPCookie *tempCookie = [NSHTTPCookie cookieWithProperties:cookieDic];
            [sharedHTTPCookieStorage setCookie:tempCookie];
        }
    }
}

/**
 获取特定url相应key的value值

 @param key cookie的key值
 @param url url，一个完整的url地址，例如https://www.baidu.com/
 @return 当前url下cookie当中当前key对应的value值
 */
- (NSString *)cookieValueWithKey:(NSString *)key forUrl:(NSURL *)url
{
    NSHTTPCookieStorage *sharedHTTPCookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];

    if ([sharedHTTPCookieStorage cookieAcceptPolicy] != NSHTTPCookieAcceptPolicyAlways) {
        [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookieAcceptPolicy:NSHTTPCookieAcceptPolicyAlways];
    }

    NSArray *cookies = [sharedHTTPCookieStorage cookiesForURL:url];
    for (NSHTTPCookie *item in cookies) {
        if ([[item name] isEqualToString:key]) {
            return [NSString stringWithString:[[item value] stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]];
        }
    }
    return nil;
}

//以下是一些将cookies本地化的操作

- (void)saveCacheCookie:(id)sender {
    NSArray *mArrCookie = [self getAllCookies];
    NSData *cookieData = [NSKeyedArchiver archivedDataWithRootObject:mArrCookie];
    [[NSUserDefaults standardUserDefaults] setObject:cookieData forKey:@&quot;cookieData&quot;];
}

- (void)unzipCookie:(id)sender {
    NSData *cookieData = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;cookieData&quot;];
    NSArray *mArrCookie = [NSKeyedUnarchiver unarchiveObjectWithData:cookieData];        
    [self setCookiesFromArr:mArrCookie];
}
</code></pre><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>针对跨域问题，可以在服务器和客户端分别做处理解决</p>
<p>服务器：在服务器返回cookie时同时将相关联的其他域的cookie返回</p>
<p>客户端：在每次请求完成后，对想跨域的域名进行设置，添加对应的cookie</p>
<p>推荐在服务器配置相关策略</p>
<h3 id="WKWebView使用cookie"><a href="#WKWebView使用cookie" class="headerlink" title="WKWebView使用cookie"></a>WKWebView使用cookie</h3><p>因为WKWebView没有缓存，不使用<code>NSHTTPCookieStorage</code>，其cookie只存在内存当中，当前页面被释放其cookie也就消失了。因此WKWebView当中的请求不能使用其他请求的cookie，同时两个WKWebView页面也不共享cookie。</p>
<p>所以想要WKWebView使用其他请求的cookie或者前一个WKWebView页面的cookie需要在WKWebView加载前执行一段js代码，将cookie设置进去，而每次WKWebView请求之后获取cookie，将其保存起来。至于存在哪里，<code>NSHTTPCookieStorage</code>和<code>NSUserDefaults</code>都是不错的选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天无意间翻到了以前有关cookies的代码，就顺便整理了一下，和大家分享下。&lt;/p&gt;
&lt;h3 id=&quot;Cookies简介&quot;&gt;&lt;a href=&quot;#Cookies简介&quot; class=&quot;headerlink&quot; title=&quot;Cookies简介&quot;&gt;&lt;/a&gt;Cookies简介&lt;/h3&gt;&lt;p&gt;这里有比较详细的介绍，本文就不再赘述了。&lt;a href=&quot;http://blog.csdn.net/fangaoxin/article/details/6952954&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;click me&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在iOS当中需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不管是NSURLConnection还是UIWebView都会保留并传递服务端的cookie，就是说基本所有的网络请求都会使用cookie&lt;/li&gt;
&lt;li&gt;多个应用之间默认不共享cookie&lt;/li&gt;
&lt;li&gt;临时cookie在应用重启之后就会消失&lt;/li&gt;
&lt;li&gt;持久cookie在应用或系统重启之后不会消失&lt;/li&gt;
&lt;li&gt;cookie不能跨域，像.baidu.com和image.baidu.com这种也是跨域&lt;/li&gt;
&lt;li&gt;WKWebView因为没有缓存，不能使用cookie，想要使用，需做特殊处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：cookie不能跨域是通用的，在所有情况下都是这样，并非在iOS系统上如此。.baidu.com和image.baidu.com可以使用彼此的cookie是因为服务端做了特殊的处理。
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
